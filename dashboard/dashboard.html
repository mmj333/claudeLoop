<!DOCTYPE html>
<html>

<head>
  <title>Claude Loop Unified Control</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script>
    // Apply theme immediately to prevent flash
    (function () {
      const themeMode = localStorage.getItem('themeMode') || 'auto';
      const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      let isDark = false;

      if (themeMode === 'auto') {
        isDark = prefersDark;
      } else if (themeMode === 'dark') {
        isDark = true;
      }

      if (isDark) {
        document.documentElement.classList.add('dark-mode');
      }
    })();
  </script>
  <style>
    /* Critical inline styles to prevent flash */
    html.dark-mode input,
    html.dark-mode textarea,
    html.dark-mode select {
      background: #2a2a2a !important;
      color: #e0e0e0 !important;
      border: 1px solid #444 !important;
    }
    
    /* Prompt notification styling - floating overlay */
    .prompt-notification {
      position: absolute;
      top: 12px;
      left: 12px;
      right: 12px;
      padding: 10px 12px;
      background: rgba(255, 243, 205, 0.98);
      border: 1px solid #ffc107;
      border-radius: 6px;
      color: #856404;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      z-index: 100;
      animation: slideDown 0.3s ease-out;
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    /* Dark mode prompt notification */
    html.dark-mode .prompt-notification {
      background: rgba(58, 53, 32, 0.98);
      border-color: #665500;
      color: #ffd966;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    }
    
    html.dark-mode .prompt-notification div {
      color: inherit !important;
    }
    
    /* Success notification */
    .prompt-notification-success {
      background: rgba(212, 237, 218, 0.98) !important;
      border-color: #28a745 !important;
      color: #155724 !important;
    }

    html.dark-mode .prompt-notification-success {
      background: rgba(26, 58, 32, 0.98) !important;
      border-color: #28a745 !important;
      color: #66ff66 !important;
    }
    
    /* Make tmux content resizable */
    .tmux-content {
      resize: vertical;
      overflow: auto;
      min-height: 300px;
      max-height: 90vh;
      height: 600px;
      font-family: 'Cascadia Code', 'Fira Code', monospace;
      font-size: 11px;
      padding: 10px;
      background: #1e1e1e;
      color: #d4d4d4;
      line-height: 1.4;
      white-space: pre;
    }
    
    /* Fix layout so controls stay attached to tmux window */
    .monitor-card {
      display: flex;
      flex-direction: column;
    }
    
    .monitor-card .card-content {
      display: flex;
      flex-direction: column;
      flex: 1;
    }
    
    .tab-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      position: relative; /* Allow absolute positioning for notification overlay */
    }
    
    .tab-panel.active {
      display: flex !important;
    }
    
    /* Pulse animation for pending todos */
    @keyframes pulse {
      0% {
        box-shadow: 0 0 0 0 rgba(var(--accent-rgb, 79, 195, 247), 0.7);
      }
      70% {
        box-shadow: 0 0 0 6px rgba(var(--accent-rgb, 79, 195, 247), 0);
      }
      100% {
        box-shadow: 0 0 0 0 rgba(var(--accent-rgb, 79, 195, 247), 0);
      }
    }
    
    /* Shimmer animation for in-progress tasks */
    @keyframes shimmer {
      0% {
        background-position: -100% 0;
      }
      100% {
        background-position: 100% 0;
      }
    }
    
    /* Pulse opacity for awaiting review */
    @keyframes pulse-opacity {
      0%, 100% {
        opacity: 0.3;
      }
      50% {
        opacity: 0.7;
      }
    }
    
    /* Toast animations */
    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }
    
    @keyframes slideOut {
      from {
        transform: translateX(0);
        opacity: 1;
      }
      to {
        transform: translateX(100%);
        opacity: 0;
      }
    }
    
    /* Todo checkbox styling */
    .todo-item button {
      transition: all 0.2s ease;
    }

    .todo-item button:hover {
      transform: scale(1.05);
    }

    /* Context menu styling */
    .context-menu-item {
      display: block;
      width: 100%;
      padding: 8px 12px;
      background: none;
      border: none;
      color: var(--text-primary);
      text-align: left;
      cursor: pointer;
      transition: background 0.2s ease;
    }

    .context-menu-item:hover {
      background: var(--bg-hover);
    }

    /* Keyboard styling */
    .kbd-key {
      min-width: 32px;
      height: 32px;
      padding: 4px 8px;
      background: var(--bg-primary);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      color: var(--text-primary);
      font-size: 12px;
      font-family: monospace;
      cursor: pointer;
      transition: all 0.15s ease;
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .kbd-key:hover {
      background: var(--bg-hover);
      border-color: var(--primary);
      transform: translateY(-1px);
    }

    .kbd-key:active {
      transform: translateY(0);
      background: var(--primary);
      color: white;
    }

    .kbd-key.active {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }

    /* Custom slider styling */
    #todo-category-slider, #todo-priority-slider {
      -webkit-appearance: none;
      appearance: none;
      outline: none;
      opacity: 0.9;
      transition: opacity 0.2s;
    }
    
    #todo-category-slider:hover, #todo-priority-slider:hover {
      opacity: 1;
    }
    
    /* Slider track */
    #todo-category-slider::-webkit-slider-runnable-track,
    #todo-priority-slider::-webkit-slider-runnable-track {
      height: 6px;
      background: var(--border-color);
      border-radius: 3px;
    }
    
    #todo-category-slider::-moz-range-track,
    #todo-priority-slider::-moz-range-track {
      height: 6px;
      background: var(--border-color);
      border-radius: 3px;
    }
    
    /* Slider thumb */
    #todo-category-slider::-webkit-slider-thumb,
    #todo-priority-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      background: var(--accent);
      cursor: pointer;
      border-radius: 50%;
      margin-top: -5px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    
    #todo-category-slider::-moz-range-thumb,
    #todo-priority-slider::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: var(--accent);
      cursor: pointer;
      border-radius: 50%;
      border: none;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
  </style>
  <link rel="stylesheet" href="/dashboard-styles.css">
</head>

<body>
  <div class="container">
    <div class="header">
      <h1>üéÆ Claude Loop Control Dashboard</h1>
      </br>
      <div class="header-actions">
        <button id="toggle-dark-mode" class="btn btn-secondary" onclick="toggleDarkMode()" title="Toggle Dark Mode">
          <span id="dark-mode-icon">üåô</span>
          <span id="dark-mode-text" style="font-size: 12px; margin-left: 4px;">Auto</span>
        </button>
        <button onclick="stopAllLoops()" class="btn btn-danger">üõë Stop All Loops</button>
        <button onclick="stopAllSessions()" class="btn btn-danger">üíÄ Kill All Sessions</button>
      </div>
    </div>

    <div class="grid" id="dashboard-grid">
      <!-- Left Column: Control Panel -->
      <div class="left-column">
        <!-- Sidebar toggle button (desktop) -->
        <div class="sidebar-toggle" onclick="toggleSidebar()" title="Toggle sidebar">
          <span id="sidebar-toggle-icon">‚óÄ</span>
        </div>

        <!-- Session Selector -->
        <div class="card session-selector" style="display: flex; flex-direction: row; align-items: center; gap: 15px; flex-wrap: wrap;">
          <div class="collapse-hint" onclick="toggleSidebar()" title="Click to expand">üì¶</div>
          <h3 style="margin: 0;">üì¶ Session</h3>
          <select id="session-select" onchange="selectSession(this.value)" style="flex: 1; min-width: 150px;">
            <option value="">Loading sessions...</option>
          </select>
          <div class="session-actions" style="display: flex; gap: 8px; flex-wrap: wrap;">
            <button onclick="createNewSession()" class="btn btn-primary">‚ûï New</button>
            <button onclick="killCurrentSession()" class="btn btn-danger">üóëÔ∏è Kill</button>
            <button onclick="restartTmux()" class="btn btn-warning">üîÑ Restart</button>
            <div style="position: relative; display: inline-block;">
              <button onclick="toggleSessionMenu()" class="btn btn-secondary">More ‚öôÔ∏è</button>
              <div id="session-menu" style="display: none; position: absolute; top: 100%; right: 0; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.2); z-index: 1000; min-width: 150px; margin-top: 4px;">
                <button onclick="forkSession(currentSession); toggleSessionMenu();" style="display: block; width: 100%; padding: 8px 12px; background: none; border: none; color: var(--text-primary); text-align: left; cursor: pointer; hover: background: var(--bg-hover);" onmouseover="this.style.background='var(--bg-hover)'" onmouseout="this.style.background='none'">
                  üìã Fork
                </button>
                <button onclick="renameSession(); toggleSessionMenu();" style="display: block; width: 100%; padding: 8px 12px; background: none; border: none; color: var(--text-primary); text-align: left; cursor: pointer; hover: background: var(--bg-hover);" onmouseover="this.style.background='var(--bg-hover)'" onmouseout="this.style.background='none'">
                  ‚úèÔ∏è Rename
                </button>
                <button onclick="deleteSession(); toggleSessionMenu();" style="display: block; width: 100%; padding: 8px 12px; background: none; border: none; color: #ff4444; text-align: left; cursor: pointer;" onmouseover="this.style.background='var(--bg-hover)'" onmouseout="this.style.background='none'">
                  üíÄ Delete Session
                </button>
              </div>
            </div>
          </div>
        </div>

        <!-- Mobile collapse toggle -->
        <div class="mobile-collapse-toggle" onclick="toggleMobileSidebar()">
          <span id="mobile-toggle-text">Hide Controls</span>
          <span id="mobile-toggle-icon">‚ñ≤</span>
        </div>

        <!-- Claude Control -->
        <div class="card">
          <div class="collapse-hint" onclick="toggleSidebar()" title="Click to expand">ü§ñ</div>
          <div class="collapse-label">Claude:</div>
          <h3>ü§ñ Claude Control</h3>
          <div class="control-buttons" style="display: flex; gap: 8px; flex-wrap: wrap;">
            <button onclick="startClaude()" class="btn btn-success" title="Start Claude in current session">
              <span class="btn-full">‚ñ∂Ô∏è Start Claude</span>
              <span class="btn-compact">‚ñ∂Ô∏è Start</span>
            </button>
            <button onclick="stopClaude()" class="btn btn-danger" title="Stop Claude (Ctrl+C)">
              <span class="btn-full">‚èπÔ∏è Stop Claude</span>
              <span class="btn-compact">‚èπÔ∏è Stop</span>
            </button>
            <button onclick="restartClaude()" class="btn btn-warning" title="Restart Claude (keeps view)">
              <span class="btn-full">üîÑ Restart Claude</span>
              <span class="btn-compact">üîÑ Restart</span>
            </button>
            <button onclick="sendCompact()" class="btn btn-info" title="Send /compact command">
              <span class="btn-full">üì¶ Compact</span>
              <span class="btn-compact">üì¶ c'pact</span>
            </button>
            <button onclick="toggleMonitoringPause()" class="btn btn-secondary" id="pause-monitoring-btn"
              title="Pause/resume tmux monitoring for this session">
              <span class="btn-full" id="pause-monitoring-text">‚è∏Ô∏è Pause Monitoring</span>
              <span class="btn-compact" id="pause-monitoring-compact">‚è∏Ô∏è Pause</span>
            </button>
            <button onclick="clearScrollback()" class="btn btn-warning"
              title="Clear tmux scrollback buffer (fixes flickering/redraw issues)">
              <span class="btn-full">üßπ Clear Scrollback</span>
              <span class="btn-compact">üßπ Clear</span>
            </button>
          </div>
        </div>

        <!-- Loop Control -->
        <div class="card">
          <div class="collapse-hint" onclick="toggleSidebar()" title="Click to expand">üîÑ</div>
          <div class="collapse-label">Loop:</div>
          <h3>üîÑ Loop Control</h3>
          <div class="loop-status" id="loop-status">
            <span class="status-indicator" id="status-indicator">‚óè</span>
            <span id="status-text">Not running</span>
            <div id="loop-countdown"
              style="font-size: 11px; color: var(--text-secondary); margin-top: 4px; display: none;">
              Next message in: <span id="countdown-time"
                style="font-weight: bold; color: var(--text-primary);">--:--</span>
            </div>
          </div>
          <div class="loop-settings"
            style="margin: 10px 0; padding: 10px; background: var(--bg-secondary); border-radius: 6px;">
            <div class="form-group" style="margin-bottom: 8px;">
              <label style="font-size: 12px;">Delay between messages (minutes):</label>
              <input type="number" id="delay-minutes" value="10" min="1" max="120" onchange="updateDelay(this.value)"
                style="width: 60px; padding: 2px 4px; font-size: 12px;">
            </div>
            <div class="form-group" style="margin: 0;">
              <label style="font-size: 12px; display: flex; align-items: center; gap: 5px;"
                title="When checked: First message after full delay. When unchecked: First message after 30 seconds (for quick testing)">
                <input type="checkbox" id="start-with-delay" checked onchange="updateStartWithDelay(this.checked)">
                Start with full delay <span style="color: var(--text-secondary); font-size: 11px;">(uncheck for 30s
                  quick start)</span>
              </label>
            </div>
            <div class="form-group" style="margin: 0;">
              <label style="font-size: 12px; display: flex; align-items: center; gap: 5px;"
                title="‚ö†Ô∏è Caution: Automatically accepts Claude's questions by pressing Enter. May approve destructive actions. Use with care!">
                <input type="checkbox" id="auto-accept-prompts" onchange="updateAutoAcceptPrompts(this.checked)">
                Auto-accept Claude prompts <span style="color: #ff9944; font-size: 11px;">‚ö†Ô∏è Use with caution</span>
              </label>
              <div style="margin-left: 20px; margin-top: 4px; display: flex; align-items: center; gap: 5px;" id="auto-accept-delay-container">
                <label style="font-size: 11px; color: var(--text-secondary);">Delay:</label>
                <input type="number" id="auto-accept-delay" value="10" min="1" max="60" 
                  style="width: 45px; padding: 1px 3px; font-size: 11px;" 
                  onchange="updateAutoAcceptDelay(this.value)"
                  title="Seconds to wait before auto-accepting (gives you time to see the prompt)">
                <span style="font-size: 11px; color: var(--text-secondary);">seconds</span>
              </div>
              <div style="margin-left: 20px; margin-top: 4px; display: flex; align-items: center; gap: 5px;" id="auto-accept-cooldown-container">
                <label style="font-size: 11px; color: var(--text-secondary);">Cooldown:</label>
                <input type="number" id="auto-accept-cooldown" value="5" min="0" max="60"
                  style="width: 45px; padding: 1px 3px; font-size: 11px;"
                  onchange="updateAutoAcceptCooldown(this.value)"
                  title="Minutes to wait between auto-accepts (0 = no cooldown)">
                <span style="font-size: 11px; color: var(--text-secondary);">min</span>
                <button onclick="resetAutoAcceptCooldown()" class="btn btn-xs" style="margin-left: 5px; padding: 0px 6px; font-size: 10px;" title="Reset cooldown timer">Reset</button>
              </div>
              <div style="margin-left: 20px; margin-top: 4px;">
                <label style="font-size: 11px; color: var(--text-secondary);"
                  title="Show notifications at the top of tmux panel when Claude is waiting for input">
                  <input type="checkbox" id="show-prompt-notifications" checked onchange="updateShowPromptNotifications(this.checked)">
                  Show prompt notifications
                </label>
              </div>
              <div style="margin-left: 20px; margin-top: 4px;">
                <label style="font-size: 11px; color: var(--text-secondary);"
                  title="Allow auto-accept to work even when loop is stopped or paused">
                  <input type="checkbox" id="auto-accept-without-loop" onchange="updateAutoAcceptWithoutLoop(this.checked)">
                  Work without loop running
                </label>
              </div>
            </div>
            <div class="form-group" style="margin: 0;">
              <label style="font-size: 12px; display: flex; align-items: center; gap: 5px;"
                title="Automatically send /compact command when Claude's context drops below threshold (only when loop is running)">
                <input type="checkbox" id="enable-auto-compact" onchange="updateEnableAutoCompact(this.checked)">
                Enable Auto-Compact <span style="color: var(--text-secondary); font-size: 11px;">(low context failsafe)</span>
              </label>
              <div style="margin-left: 20px; margin-top: 4px; display: flex; align-items: center; gap: 5px;" id="auto-compact-threshold-container">
                <label style="font-size: 11px; color: var(--text-secondary);">Trigger below:</label>
                <input type="number" id="auto-compact-threshold" value="5" min="1" max="20"
                  style="width: 45px; padding: 1px 3px; font-size: 11px;"
                  onchange="updateAutoCompactThreshold(this.value)"
                  title="Context percentage threshold - compact when context drops below this %">
                <span style="font-size: 11px; color: var(--text-secondary);">% context</span>
              </div>
            </div>
            <div class="form-group" style="margin-top: 8px;">
              <label style="font-size: 12px;">Message send delay (seconds before Enter):</label>
              <div style="display: flex; align-items: center; gap: 5px;">
                <input type="number" id="message-send-delay" value="5" min="1" max="30" 
                  style="width: 50px; padding: 2px 4px; font-size: 12px;" 
                  onchange="updateMessageSendDelay(this.value)"
                  title="Seconds to wait after sending message before pressing Enter">
                <label style="font-size: 11px; color: var(--text-secondary);" 
                  title="Send Enter key twice to ensure message is sent (helps when tmux is sluggish)">
                  <input type="checkbox" id="retry-enter-key" checked onchange="updateRetryEnterKey(this.checked)">
                  Retry Enter key
                </label>
              </div>
            </div>
          </div>
          <div class="control-buttons">
            <button onclick="startOrResumeLoop()" class="btn btn-success" id="start-resume-btn">‚ñ∂Ô∏è Start</button>
            <button onclick="pauseLoop()" class="btn btn-warning" id="pause-btn">‚è∏Ô∏è Pause</button>
            <button onclick="stopLoop()" class="btn btn-danger">‚èπÔ∏è Stop</button>
          </div>
        </div>



        <!-- Schedule with full visualization -->
        <div class="card schedule-card collapsed" id="schedule-card">
          <div class="collapse-hint" onclick="toggleSidebar()" title="Click to expand">üìÖ</div>
          <h3 onclick="toggleSchedule()" style="cursor: pointer;">
            üìÖ Schedule <span class="toggle">‚ñ∂</span>
          </h3>
          <div class="schedule-content" id="schedule-content" style="display: none;">
            <!-- Tool Selection -->
            <div class="schedule-tools">
              <label class="tool-option">
                <input type="radio" name="schedule-tool" value="active" checked>
                <span class="tool-label active-tool">‚úÖ Active</span>
              </label>
              <label class="tool-option">
                <input type="radio" name="schedule-tool" value="inactive">
                <span class="tool-label inactive-tool">‚õî Inactive</span>
              </label>
              <div class="precision-selector">
                <label>Precision:</label>
                <select id="schedule-precision">
                  <option value="1">1 min</option>
                  <option value="5">5 min</option>
                  <option value="10">10 min</option>
                  <option value="15" selected>15 min</option>
                  <option value="30">30 min</option>
                  <option value="60">1 hour</option>
                </select>
              </div>
            </div>

            <!-- Timezone Display -->
            <div class="timezone-display" id="timezone-display">
              Timezone: Loading...
            </div>

            <!-- Timeline Visualization -->
            <div class="timeline-container">
              <div id="time-tooltip" class="time-tooltip"></div>

              <!-- AM Timeline -->
              <div class="timeline-section">
                <div class="timeline-label">AM</div>
                <div id="schedule-timeline-am" class="schedule-timeline">
                  <!-- Timeline blocks will be generated here -->
                </div>
                <div class="timeline-hours">
                  <span style="left: 0%;">12</span>
                  <span style="left: 8.33%;">1</span>
                  <span style="left: 16.67%;">2</span>
                  <span style="left: 25%;">3</span>
                  <span style="left: 33.33%;">4</span>
                  <span style="left: 41.67%;">5</span>
                  <span style="left: 50%;">6</span>
                  <span style="left: 58.33%;">7</span>
                  <span style="left: 66.67%;">8</span>
                  <span style="left: 75%;">9</span>
                  <span style="left: 83.33%;">10</span>
                  <span style="left: 91.67%;">11</span>
                </div>
              </div>

              <!-- PM Timeline -->
              <div class="timeline-section">
                <div class="timeline-label">PM</div>
                <div id="schedule-timeline-pm" class="schedule-timeline">
                  <!-- Timeline blocks will be generated here -->
                </div>
                <div class="timeline-hours">
                  <span style="left: 0%;">12</span>
                  <span style="left: 8.33%;">1</span>
                  <span style="left: 16.67%;">2</span>
                  <span style="left: 25%;">3</span>
                  <span style="left: 33.33%;">4</span>
                  <span style="left: 41.67%;">5</span>
                  <span style="left: 50%;">6</span>
                  <span style="left: 58.33%;">7</span>
                  <span style="left: 66.67%;">8</span>
                  <span style="left: 75%;">9</span>
                  <span style="left: 83.33%;">10</span>
                  <span style="left: 91.67%;">11</span>
                </div>
              </div>
            </div>

            <!-- Quick Presets -->
            <div class="schedule-presets">
              <button onclick="dashboardSchedule.setAllHours(true)" class="btn btn-sm">All Active</button>
              <button onclick="dashboardSchedule.setAllHours(false)" class="btn btn-sm">All Inactive</button>
              <button onclick="dashboardSchedule.setWorkHours()" class="btn btn-sm">9-5</button>
              <button onclick="dashboardSchedule.setNightHours()" class="btn btn-sm">Night</button>
            </div>
          </div>
        </div>

        <!-- Conditional Messages -->
        <div class="card conditional-card collapsed" id="conditional-card">
          <div class="collapse-hint" onclick="toggleSidebar()" title="Click to expand">‚ö°</div>
          <h3 onclick="dashboardConditional.toggleCard()" style="cursor: pointer;">
            ‚ö° Conditional Messages <span class="toggle">‚ñ∂</span>
          </h3>
          <div class="conditional-content" id="conditional-content" style="display: none;">
            <!-- Content generated by dashboard-conditional.js -->
          </div>
        </div>

        <!-- Log Monitor Controls -->
        <div class="card">
          <div class="collapse-hint" onclick="toggleSidebar()" title="Click to expand">üìù</div>
          <h3>üìù Log Monitor</h3>
          <div class="log-monitor-controls">
            <div class="monitor-status" id="monitor-status">
              <span class="status-indicator running" id="monitor-indicator">‚óè</span>
              <span id="monitor-text">Running</span>
            </div>
            <div class="control-buttons">
              <button onclick="startLogMonitor()" class="btn btn-success btn-sm">‚ñ∂Ô∏è Start</button>
              <button onclick="stopLogMonitor()" class="btn btn-danger btn-sm">‚èπÔ∏è Stop</button>
              <button onclick="listLogMonitors()" class="btn btn-info btn-sm">üìã List</button>
            </div>
            <div class="monitor-info" id="monitor-info">
              <small>Monitoring: <span id="monitor-files">claude-loop*.log</span></small>
            </div>
          </div>
        </div>
      </div>

      <!-- Right Column: Monitoring -->
      <div class="right-column">
        <!-- Working Directory -->
        <div class="card" style="padding: 12px 20px; margin-bottom: 15px;">
          <div style="display: flex; align-items: center; gap: 10px;">
            <label style="margin: 0; font-weight: 600; color: var(--accent);">üìÅ Working Directory:</label>
            <input type="text" id="working-directory"
              style="flex: 1; padding: 6px 10px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--bg-tertiary); color: var(--text-primary);"
              placeholder="Select a folder for Claude to work in" onchange="updateWorkingDirectory(this.value)">
            <button onclick="useSessionCwd()" class="btn btn-sm btn-secondary"
              title="Use current session's working directory" id="session-cwd-btn">
              üìç
            </button>
            <button onclick="browseDirectory()" class="btn btn-sm btn-secondary" title="Browse for folder">
              üìÇ
            </button>
          </div>
        </div>

        <!-- Tabbed Monitor -->
        <div class="card monitor-card">
          <!-- Session Tabs - Added above tmux/chat tabs for easy switching -->
          <div class="session-tabs-container" id="session-tabs-container" style="display: none;">
            <div class="session-tabs" id="session-tabs">
              <!-- Session tabs will be dynamically added here -->
            </div>
          </div>

          <!-- Legend tooltip (shows on click) -->
          <div class="legend-tooltip" id="legend-tooltip" style="display: none;">
            <strong>Tab Indicators:</strong>
            <div class="legend-item"><span class="legend-emoji">‚ö†Ô∏è</span> Waiting for input (yellow glow)</div>
            <div class="legend-item"><span class="legend-emoji">‚úÖ</span> Auto-accepted prompt (green glow)</div>
            <div class="legend-item"><span class="legend-bar" style="background: #ff9800;"></span> Low context (&lt;30%)</div>
            <div class="legend-item"><span class="legend-bar" style="background: #f44336;"></span> Very low context (&lt;10%)</div>
          </div>
          
          <div class="card-header">
            <div class="tab-buttons">
              <button id="tmux-tab" class="tab-button active" onclick="switchTab('tmux')">
                üñ•Ô∏è Tmux
              </button>
              <button id="chat-tab" class="tab-button" onclick="switchTab('chat')">
                üí¨ Chat
              </button>
              <button class="legend-button" onclick="toggleLegend()" title="Show tab indicator legend">‚ÑπÔ∏è</button>
            </div>
            <div class="monitor-controls">
              <select id="tmux-lines" onchange="updateTmuxLines()" class="btn btn-sm"
                style="padding: 4px 8px; margin-right: 8px;">
                <option value="200">200 lines</option>
                <option value="500" selected>500 lines</option>
                <option value="1000">1000 lines</option>
                <option value="2000">2000 lines</option>
                <option value="0">All lines</option>
              </select>
              <select id="tmux-font-size" onchange="updateTmuxFontSize()" class="btn btn-sm"
                style="padding: 4px 8px; margin-right: 8px;">
                <option value="8">8px</option>
                <option value="9">9px</option>
                <option value="10">10px</option>
                <option value="11" selected>11px</option>
                <option value="12">12px</option>
                <option value="13">13px</option>
                <option value="14">14px</option>
                <option value="15">15px</option>
                <option value="16">16px</option>
                <option value="17">17px</option>
                <option value="18">18px</option>
                <option value="19">19px</option>
                <option value="20">20px</option>
                <option value="21">21px</option>
                <option value="22">22px</option>
                <option value="23">23px</option>
                <option value="24">24px</option>
                <option value="25">25px</option>
                <option value="26">26px</option>
                <option value="27">27px</option>
              </select>
              <select id="tmux-refresh-rate" onchange="updateTmuxRefreshRate()" class="btn btn-sm"
                style="padding: 4px 8px; margin-right: 8px;">
                <option value="0">‚è∏ Paused</option>
                <option value="1000">üîÑ 1s</option>
                <option value="2000">üîÑ 2s</option>
                <option value="3000">üîÑ 3s</option>
                <option value="5000" selected>üîÑ 5s</option>
                <option value="10000">üîÑ 10s</option>
                <option value="30000">üîÑ 30s</option>
              </select>
              <button onclick="refreshCurrentTab()" class="btn btn-sm btn-secondary">üîÑ</button>
              <button onclick="clearCurrentTab()" class="btn btn-sm btn-secondary">üóëÔ∏è</button>
              <label>
                <input type="checkbox" id="auto-scroll" checked> Auto-scroll
              </label>
              <label title="Monitor all background tabs, or only tabs with auto-accept/loop running">
                <input type="checkbox" id="monitor-all-tabs" checked onchange="updateMonitoringMode()">
                üì° All Tabs
              </label>
            </div>
          </div>
          
          <!-- Card content wrapper for proper flex layout -->
          <div class="card-content">
            <!-- Tmux Tab Content -->
            <div id="tmux-panel" class="tab-panel active">
            <!-- Interactive Prompt Notification -->
            <div id="prompt-notification" class="prompt-notification" style="display: none;">
              <div style="display: flex; align-items: center; gap: 8px;">
                <span id="prompt-icon" style="font-size: 18px;">‚ö†Ô∏è</span>
                <div style="flex: 1;">
                  <div style="font-weight: bold;" id="prompt-title">Claude is waiting for input</div>
                  <div style="font-size: 12px; margin-top: 2px; opacity: 0.9;" id="prompt-content"></div>
                  <div style="font-size: 11px; margin-top: 4px; opacity: 0.8;" id="prompt-status"></div>
                </div>
                <button onclick="dismissPromptNotification()" class="btn btn-xs" title="Dismiss this notification" style="margin-left: auto;">‚úï</button>
              </div>
            </div>
            <div class="tmux-content" id="tmux-content">
              <div class="loading">Loading tmux output...</div>
            </div>
          </div>

          <!-- Chat Tab Content -->
          <div id="chat-panel" class="tab-panel" style="display: none;">
            <div class="chat-controls"
              style="padding: 8px; background: var(--bg-secondary); border-bottom: 1px solid var(--border); display: flex; gap: 8px; align-items: center;">
              <button onclick="dashboardChat.autoAssociateConversation()" class="btn btn-sm"
                title="Auto-detect conversation from tmux content">
                üîç Auto-detect conversation
              </button>
              <div style="margin-left: auto; display: flex; align-items: center; gap: 8px;">
                <label style="font-size: 11px; color: var(--text-secondary);">Font size:</label>
                <select id="chat-font-size" onchange="updateChatFontSize()"
                  style="padding: 2px 6px; font-size: 11px; background: var(--bg-primary); color: var(--text-primary); border: 1px solid var(--border); border-radius: 4px;">
                  <option value="10">10px</option>
                  <option value="11" selected>11px</option>
                  <option value="12">12px</option>
                  <option value="13">13px</option>
                  <option value="14">14px</option>
                  <option value="15">15px</option>
                  <option value="16">16px</option>
                  <option value="18">18px</option>
                  <option value="20">20px</option>
                  <option value="22">22px</option>
                  <option value="24">24px</option>
                  <option value="27">27px</option>
                </select>
              </div>
              <div id="conversation-association" style="text-align: right; font-size: 12px; color: var(--text-muted);">
                <!-- Association status will be shown here -->
              </div>
            </div>
            <div class="chat-content" id="chat-content">
              <div class="loading">Loading chat messages...</div>
            </div>
            
            <!-- Compact tmux status view (only in chat tab) -->
            <div class="tmux-status-view" id="tmux-status-view" style="border-top: 1px solid var(--border); background: var(--bg-primary); transition: height 0.3s ease;">
              <div style="display: flex; justify-content: space-between; align-items: center; padding: 4px 8px; background: var(--bg-secondary); border-bottom: 1px solid var(--border);">
                <span style="font-size: 11px; color: var(--text-secondary);">üìü Tmux Status</span>
                <button onclick="toggleTmuxStatus()" class="btn btn-xs" id="tmux-status-toggle">‚ñº Expand</button>
              </div>
              <div class="tmux-status-content" id="tmux-status-content" style="height: 80px; overflow-y: auto; padding: 4px 8px; font-family: 'Monaco', 'Menlo', monospace; font-size: 11px; line-height: 1.3;">
                <div class="loading" style="font-size: 11px;">Loading status...</div>
              </div>
            </div>
          </div>
          
          <!-- Shared controls for both tabs -->
          <!-- Context info row (slim, right-aligned) -->
          <div style="display: flex; justify-content: flex-end; padding: 2px 8px; margin-bottom: 4px;">
            <div class="context-compact">
              <span class="context-label" id="context-main-label">Context:</span>
              <div class="context-bar-inline" style="width: 80px;">
                <div class="context-fill-inline" id="context-fill-inline" style="width: 100%"></div>
              </div>
              <span class="context-percent" id="context-percent">100%</span>
              <span class="context-separator">|</span>
              <span class="refresh-indicator" id="refresh-indicator"
                    style="font-size: 11px; color: #666;">
                üîÑ 5s
              </span>
              <span class="context-separator">|</span>
              <span class="context-label" id="context-used-label">Used:</span>
              <span class="context-estimate" id="context-estimate">~0%</span>
            </div>
          </div>

          <!-- Tmux controls row -->
          <div class="context-status-bar" style="display: flex; justify-content: flex-start; padding: 4px 8px; overflow-x: auto;">
            <div class="tmux-controls" style="display: flex; gap: 4px; min-width: min-content;">
              <button onclick="sendTmuxKey('Escape')" class="btn btn-xs" title="Send Escape">Esc</button>
              <button onclick="sendTmuxKey('C-b')" class="btn btn-xs" title="Send Ctrl+B (tmux prefix)">Ctrl+B</button>
              <span style="margin-right: 16px;"></span>
              <button onclick="sendTmuxKey('Tab')" class="btn btn-xs" title="Send Tab">Tab</button>
              <button onclick="sendTmuxKey('BTab')" class="btn btn-xs" title="Send Shift+Tab">Shift+Tab</button>
              <button onclick="sendTmuxKey('C-c')" class="btn btn-xs" title="Send Ctrl+C">Ctrl+C</button>
              <button onclick="sendTmuxKey('C-r')" class="btn btn-xs" title="Resume conversation (Ctrl+R)">Ctrl+R</button>
              <button onclick="sendTmuxKey('Enter')" class="btn btn-xs" title="Send Enter">Enter</button>
              <button onclick="sendTmuxKey('Left')" class="btn btn-xs" title="Send Left arrow">‚Üê</button>
              <button onclick="sendTmuxKey('Up')" class="btn btn-xs" title="Send Up arrow">‚Üë</button>
              <button onclick="sendTmuxKey('Down')" class="btn btn-xs" title="Send Down arrow">‚Üì</button>
              <button onclick="sendTmuxKey('Right')" class="btn btn-xs" title="Send Right arrow">‚Üí</button>
              <span style="margin-left: 8px; margin-right: 8px;"></span>
              <button onclick="sendCompact()" class="btn btn-xs" title="Send /compact command">üì¶ /compact</button>
              <button onclick="sendConfig()" class="btn btn-xs" title="Send /config command">‚öôÔ∏è /config</button>
              <button onclick="sendForwardSlash()" class="btn btn-xs" title="Send forward slash">/ </button>
              <span style="margin-left: 8px; margin-right: 8px;"></span>
              <button onclick="toggleKeyboard()" class="btn btn-xs" id="keyboard-toggle" title="Toggle on-screen keyboard">‚å®Ô∏è Keyboard</button>
            </div>
          </div>

          <!-- On-screen Keyboard -->
          <div id="on-screen-keyboard" style="display: none; padding: 12px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 4px; margin-top: 8px;">
            <div style="display: flex; flex-direction: column; gap: 4px;">
              <!-- Number row -->
              <div style="display: flex; gap: 2px;">
                <button onclick="sendChar('`')" class="kbd-key">`</button>
                <button onclick="sendChar('1')" class="kbd-key">1</button>
                <button onclick="sendChar('2')" class="kbd-key">2</button>
                <button onclick="sendChar('3')" class="kbd-key">3</button>
                <button onclick="sendChar('4')" class="kbd-key">4</button>
                <button onclick="sendChar('5')" class="kbd-key">5</button>
                <button onclick="sendChar('6')" class="kbd-key">6</button>
                <button onclick="sendChar('7')" class="kbd-key">7</button>
                <button onclick="sendChar('8')" class="kbd-key">8</button>
                <button onclick="sendChar('9')" class="kbd-key">9</button>
                <button onclick="sendChar('0')" class="kbd-key">0</button>
                <button onclick="sendChar('-')" class="kbd-key">-</button>
                <button onclick="sendChar('=')" class="kbd-key">=</button>
                <button onclick="sendTmuxKey('BSpace')" class="kbd-key" style="flex: 1.5;">‚å´</button>
              </div>
              <!-- Top row -->
              <div style="display: flex; gap: 2px;">
                <button onclick="sendTmuxKey('Tab')" class="kbd-key" style="flex: 1.2;">Tab</button>
                <button onclick="sendChar('q')" class="kbd-key">q</button>
                <button onclick="sendChar('w')" class="kbd-key">w</button>
                <button onclick="sendChar('e')" class="kbd-key">e</button>
                <button onclick="sendChar('r')" class="kbd-key">r</button>
                <button onclick="sendChar('t')" class="kbd-key">t</button>
                <button onclick="sendChar('y')" class="kbd-key">y</button>
                <button onclick="sendChar('u')" class="kbd-key">u</button>
                <button onclick="sendChar('i')" class="kbd-key">i</button>
                <button onclick="sendChar('o')" class="kbd-key">o</button>
                <button onclick="sendChar('p')" class="kbd-key">p</button>
                <button onclick="sendChar('[')" class="kbd-key">[</button>
                <button onclick="sendChar(']')" class="kbd-key">]</button>
                <button onclick="sendChar('\\\\')" class="kbd-key">\\</button>
              </div>
              <!-- Home row -->
              <div style="display: flex; gap: 2px;">
                <button onclick="sendTmuxKey('Escape')" class="kbd-key" style="flex: 1.3;">Esc</button>
                <button onclick="sendChar('a')" class="kbd-key">a</button>
                <button onclick="sendChar('s')" class="kbd-key">s</button>
                <button onclick="sendChar('d')" class="kbd-key">d</button>
                <button onclick="sendChar('f')" class="kbd-key">f</button>
                <button onclick="sendChar('g')" class="kbd-key">g</button>
                <button onclick="sendChar('h')" class="kbd-key">h</button>
                <button onclick="sendChar('j')" class="kbd-key">j</button>
                <button onclick="sendChar('k')" class="kbd-key">k</button>
                <button onclick="sendChar('l')" class="kbd-key">l</button>
                <button onclick="sendChar(';')" class="kbd-key">;</button>
                <button onclick="sendSingleQuote()" class="kbd-key">&#39;</button>
                <button onclick="sendTmuxKey('Enter')" class="kbd-key" style="flex: 1.8;">‚Üµ</button>
              </div>
              <!-- Bottom row -->
              <div style="display: flex; gap: 2px;">
                <button onclick="toggleShift()" class="kbd-key" id="shift-key" style="flex: 1.5;">‚áß Shift</button>
                <button onclick="sendChar('z')" class="kbd-key">z</button>
                <button onclick="sendChar('x')" class="kbd-key">x</button>
                <button onclick="sendChar('c')" class="kbd-key">c</button>
                <button onclick="sendChar('v')" class="kbd-key">v</button>
                <button onclick="sendChar('b')" class="kbd-key">b</button>
                <button onclick="sendChar('n')" class="kbd-key">n</button>
                <button onclick="sendChar('m')" class="kbd-key">m</button>
                <button onclick="sendChar(',')" class="kbd-key">,</button>
                <button onclick="sendChar('.')" class="kbd-key">.</button>
                <button onclick="sendChar('/')" class="kbd-key">/</button>
                <button onclick="toggleShift()" class="kbd-key" style="flex: 1.5;">‚áß Shift</button>
              </div>
              <!-- Space row -->
              <div style="display: flex; gap: 2px;">
                <button onclick="toggleCtrl()" class="kbd-key" id="ctrl-key" style="flex: 1;">Ctrl</button>
                <button onclick="toggleAlt()" class="kbd-key" id="alt-key" style="flex: 1;">Alt</button>
                <button onclick="sendChar(' ')" class="kbd-key" style="flex: 5;">Space</button>
                <button onclick="sendTmuxKey('Left')" class="kbd-key">‚Üê</button>
                <button onclick="sendTmuxKey('Down')" class="kbd-key">‚Üì</button>
                <button onclick="sendTmuxKey('Up')" class="kbd-key">‚Üë</button>
                <button onclick="sendTmuxKey('Right')" class="kbd-key">‚Üí</button>
              </div>
            </div>
          </div>

          <div class="custom-message-input" style="display: flex; gap: 10px; align-items: center;">
            <textarea id="custom-message"
              placeholder="Enter message to send to Claude... (Hold Enter for 0.7 sec to send)"
              rows="4"
              style="resize: vertical; min-height: 80px; max-height: 400px; flex: 1;"></textarea>
            <div style="display: flex; flex-direction: column; gap: 8px; align-items: center;">
              <button onclick="sendCustomMessage()" class="btn btn-primary" style="position: relative;">
                Send Message
                <svg id="enter-progress"
                  style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 100%; height: 100%; pointer-events: none; display: none;">
                  <circle cx="50%" cy="50%" r="18" fill="none" stroke="rgba(255,255,255,0.3)" stroke-width="3"></circle>
                  <circle id="progress-circle" cx="50%" cy="50%" r="18" fill="none" stroke="#fff" stroke-width="3"
                    stroke-dasharray="113" stroke-dashoffset="113"
                    style="transform: rotate(-90deg); transform-origin: center; transition: none;"></circle>
                  <!-- Checkmark that appears when complete -->
                  <path id="progress-checkmark" d="M 42 50 L 48 56 L 58 46"
                    fill="none" stroke="#4CAF50" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"
                    style="display: none;"></path>
                </svg>
              </button>
              <label style="display: flex; align-items: center; gap: 4px; cursor: pointer; font-size: 11px; color: var(--text-secondary); white-space: nowrap;">
                <input type="checkbox" id="include-timestamp" checked style="cursor: pointer;">
                <span>Timestamp</span>
              </label>
            </div>
          </div>
          <div style="font-size: 10px; color: var(--text-secondary); margin-top: 5px;">
            <strong>Keyboard shortcuts:</strong> Hold Enter 0.7 sec = Send to Claude | Ctrl+Up/Down = Message history |
            Ctrl+Enter = Send Enter to tmux | Alt+Arrows = Navigate tmux | Alt+Enter = Send Enter | Esc = Send Escape
          </div>
          </div> <!-- End card-content -->
        </div>

        <!-- Conversations Tree (moved to right column for more width) -->
        <div class="card conversations-card collapsed" id="conversations-card">
          <h3 onclick="if(window.dashboardConversations) dashboardConversations.togglePanel(); else console.error('dashboardConversations not loaded yet');" style="cursor: pointer;">
            üóÇÔ∏è Conversations <span class="toggle">‚ñ∂</span>
          </h3>
          <div class="conversations-content" id="conversations-content" style="display: none;">
            <div class="conversation-controls"
              style="margin-bottom: 10px; display: flex; align-items: center; gap: 8px;">
              <button onclick="if(window.dashboardConversations) dashboardConversations.refresh(); else console.error('dashboardConversations not loaded');" class="btn btn-sm btn-secondary"
                title="Quick refresh - Updates the list using cached data. Fast but may miss very recent changes.">
                üîÑ Refresh
              </button>
              <button onclick="if(window.dashboardConversations) dashboardConversations.fullRefresh(); else console.error('dashboardConversations not loaded');" class="btn btn-sm btn-warning"
                title="Full scan - Reads all conversation files to rebuild the cache. Slower but finds all changes, parent-child relationships, and updates titles. Use after creating new conversations or forking.">
                üìä Full Scan
              </button>
              <button onclick="dashboardConversations.autoSelectConversation().catch(err => alert('Failed to auto-select: ' + err.message));" class="btn btn-sm btn-info"
                title="Auto-select - Automatically selects the conversation for the current Claude session. Use this to sync the chat view with your active conversation.">
                üéØ Auto-Select
              </button>
              <button onclick="dashboardConversations.toggleActionButtons()" class="btn btn-sm"
                title="Toggle action buttons visibility" id="toggle-actions-btn">
                <span id="toggle-actions-icon">üëÅÔ∏è</span>
              </button>
              <input type="text" id="conversation-search" placeholder="Search conversations..."
                style="flex: 1; padding: 4px 8px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--bg-tertiary); color: var(--text-primary);"
                onkeyup="dashboardConversations.filterConversations(this.value)">
            </div>
            <div id="conversation-tree" style="max-height: 500px; overflow-y: auto;">
              <!-- Tree will be rendered here -->
            </div>
          </div>
        </div>

        <!-- Claude's Native Todos Panel -->
        <div class="card native-todos-card" id="native-todos-card">
          <h3 style="display: flex; align-items: center; gap: 5px;">
            <span onclick="dashboardNativeTodos.togglePanel()" style="cursor: pointer; display: flex; align-items: center; gap: 5px;">
              ü§ñ Claude's Active Tasks <span class="toggle" id="native-todo-toggle">‚ñº</span>
            </span>
            <span class="native-todo-badge" id="native-todo-count" style="background: var(--primary); color: white; border-radius: 10px; padding: 2px 6px; font-size: 10px; display: none;">0</span>
            <span id="native-todo-session" style="font-size: 11px; color: var(--text-secondary); margin-left: 10px;"></span>
            <button onclick="dashboardNativeTodos.refresh()" class="btn btn-xs" id="native-todo-refresh-btn"
                    style="margin-left: auto; padding: 4px 8px;" title="Refresh tasks">
              üîÑ
            </button>
          </h3>
          <div class="native-todos-content" id="native-todos-content" style="display: block; padding: 10px; min-height: 50px;">
            <!-- Add task input -->
            <div style="display: flex; gap: 6px; margin-bottom: 10px;" id="native-todo-input-container">
              <input type="text" id="native-todo-input" placeholder="Add task for Claude..."
                     style="flex: 1; padding: 6px; border: 1px solid var(--border-color); border-radius: 4px; font-size: 12px;"
                     onkeydown="if(event.key === 'Enter') { event.preventDefault(); dashboardNativeTodos.addTask(); }">
              <button onclick="dashboardNativeTodos.addTask()" class="btn btn-sm">‚ûï Add</button>
            </div>
            <div id="native-todo-list" style="font-size: 12px;">
              <div style="color: var(--text-secondary); font-style: italic;">Select a conversation to view Claude's tasks</div>
            </div>
          </div>
        </div>

        <!-- Todo List Panel -->
        <div class="card todos-card" id="todos-card">
          <h3 style="display: flex; align-items: center; gap: 5px;">
            <span onclick="toggleTodoPanel()" style="cursor: pointer; display: flex; align-items: center; gap: 5px;">
              ‚úÖ Todo List <span class="toggle" id="todo-toggle">‚ñº</span>
            </span>
            <span class="todo-badge" id="todo-count" style="background: var(--accent); color: white; border-radius: 10px; padding: 2px 6px; font-size: 10px;">0</span>
            <button onclick="toggleProjectSidebar(event)" class="btn btn-xs" style="margin-left: 10px; padding: 2px 8px;" title="Toggle project sidebar">
              <span id="sidebar-toggle-icon">üìÅ</span>
            </button>
            <select id="todo-project-filter" onchange="filterByProject()" class="btn btn-xs" style="margin-left: 8px; padding: 2px 6px; font-size: 11px;" title="Filter by project">
              <option value="all">All Projects</option>
              <!-- Projects will be populated dynamically -->
            </select>
          </h3>
          <div class="todos-content" id="todos-content" style="display: block; position: relative;">
            <!-- Project Sidebar -->
            <div id="project-sidebar" style="position: absolute; left: 0; top: 0; bottom: 0; width: 200px; background: var(--bg-secondary); border-right: 1px solid var(--border-color); transform: translateX(-100%); transition: transform 0.3s ease; z-index: 10; display: none;">
              <div style="padding: 10px; border-bottom: 1px solid var(--border-color);">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                  <span style="font-weight: 500; font-size: 13px;">Projects</span>
                  <button onclick="toggleProjectSidebar()" class="btn btn-xs" style="padding: 2px 4px; font-size: 16px;" title="Close sidebar">√ó</button>
                </div>
              </div>
              <div id="project-list" style="padding: 8px;">
                <!-- Project folders will be populated here -->
              </div>
              <div id="new-project-dropzone" 
                   style="padding: 12px; margin: 8px; border: 2px dashed var(--border-color); border-radius: 4px; text-align: center; opacity: 0.6; transition: all 0.2s;"
                   ondragover="event.preventDefault(); this.style.background='var(--accent)'; this.style.opacity='1';"
                   ondragleave="this.style.background=''; this.style.opacity='0.6';"
                   ondrop="handleNewProjectDrop(event)">
                <span style="font-size: 13px;">+ Drop here for new project</span>
              </div>
            </div>
            
            <!-- Main Todo Container -->
            <div id="todo-main-container" style="transition: margin-left 0.3s ease;">
              <div class="todo-controls" style="margin-bottom: 10px; display: flex; gap: 8px; flex-wrap: wrap;">
              <div style="display: flex; gap: 4px; flex: 1; align-items: flex-start;">
                <textarea id="new-todo-input" 
                  placeholder="Add new todo... (Alt+T or Ctrl+Enter to save)" 
                  style="flex: 1; padding: 6px 10px; border: 1px solid var(--border-color); border-radius: 4px; min-height: 35px; max-height: 120px; resize: vertical; font-family: inherit; font-size: inherit; line-height: 1.4;"
                  onkeydown="if((event.ctrlKey || event.metaKey) && event.key === 'Enter') { event.preventDefault(); addTodo(); }"></textarea>
                <select id="new-todo-project" class="btn btn-sm" style="min-width: 120px; align-self: flex-start;">
                  <!-- Will be populated with current session by default -->
                </select>
              </div>
              
              <!-- Priority slider -->
              <div style="display: flex; flex-direction: column; padding: 8px; background: var(--bg-tertiary); border-radius: 6px; min-width: 140px;">
                <!-- Priority indicators above slider -->
                <div style="display: flex; justify-content: space-between; padding: 0 2px; margin-bottom: 8px;">
                  <span style="font-size: 18px; cursor: pointer; opacity: 0.8; transition: opacity 0.2s;" 
                        onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.8'"
                        onclick="setPrioritySlider(0)" title="Low Priority - Take your time">üê¢</span>
                  <span style="font-size: 18px; cursor: pointer; opacity: 0.8; transition: opacity 0.2s;" 
                        onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.8'"
                        onclick="setPrioritySlider(1)" title="Normal Priority - Steady pace">üêé</span>
                  <span style="font-size: 18px; cursor: pointer; opacity: 0.8; transition: opacity 0.2s;" 
                        onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.8'"
                        onclick="setPrioritySlider(2)" title="High Priority - Need speed!">üöÄ</span>
                </div>
                <!-- Slider track with dots underneath -->
                <div style="position: relative; padding: 4px 0;">
                  <input type="range" id="todo-priority-slider" min="0" max="2" value="1" step="1"
                    style="width: 100%; cursor: pointer;"
                    oninput="updatePriorityFromSlider(this.value)">
                  <!-- Dots under the slider track -->
                  <div style="display: flex; justify-content: space-between; margin-top: 2px; padding: 0 7px;">
                    <div style="width: 4px; height: 4px; background: var(--text-secondary); border-radius: 50%; opacity: 0.5;"></div>
                    <div style="width: 4px; height: 4px; background: var(--text-secondary); border-radius: 50%; opacity: 0.5;"></div>
                    <div style="width: 4px; height: 4px; background: var(--text-secondary); border-radius: 50%; opacity: 0.5;"></div>
                  </div>
                </div>
                <!-- Current selection label -->
                <div style="text-align: center; margin-top: 6px;">
                  <span style="font-size: 11px; color: var(--text-secondary);">Priority: </span>
                  <span id="priority-label" style="font-size: 12px; font-weight: 500; color: var(--text-primary);">Normal</span>
                </div>
              </div>
              
              <!-- Category slider -->
              <div style="display: flex; flex-direction: column; padding: 8px; background: var(--bg-tertiary); border-radius: 6px; min-width: 160px;">
                <!-- Emoji markers above slider -->
                <div style="display: flex; justify-content: space-between; padding: 0 2px; margin-bottom: 8px;">
                  <span style="font-size: 18px; cursor: pointer; opacity: 0.8; transition: opacity 0.2s;" 
                        onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.8'"
                        onclick="setCategorySlider(0)" title="Bug">üêõ</span>
                  <span style="font-size: 18px; cursor: pointer; opacity: 0.8; transition: opacity 0.2s;" 
                        onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.8'"
                        onclick="setCategorySlider(1)" title="Feature">‚ú®</span>
                  <span style="font-size: 18px; cursor: pointer; opacity: 0.8; transition: opacity 0.2s;" 
                        onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.8'"
                        onclick="setCategorySlider(2)" title="Research">üîç</span>
                  <span style="font-size: 18px; cursor: pointer; opacity: 0.8; transition: opacity 0.2s;" 
                        onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.8'"
                        onclick="setCategorySlider(3)" title="Other">üìù</span>
                </div>
                <!-- Slider track with dots underneath -->
                <div style="position: relative; padding: 4px 0;">
                  <input type="range" id="todo-category-slider" min="0" max="3" value="3" step="1"
                    style="width: 100%; cursor: pointer;"
                    oninput="updateCategoryFromSlider(this.value)">
                  <!-- Dots under the slider track -->
                  <div style="display: flex; justify-content: space-between; margin-top: 2px; padding: 0 7px;">
                    <div style="width: 4px; height: 4px; background: var(--text-secondary); border-radius: 50%; opacity: 0.5;"></div>
                    <div style="width: 4px; height: 4px; background: var(--text-secondary); border-radius: 50%; opacity: 0.5;"></div>
                    <div style="width: 4px; height: 4px; background: var(--text-secondary); border-radius: 50%; opacity: 0.5;"></div>
                    <div style="width: 4px; height: 4px; background: var(--text-secondary); border-radius: 50%; opacity: 0.5;"></div>
                  </div>
                </div>
                <!-- Current selection label -->
                <div style="text-align: center; margin-top: 6px;">
                  <span style="font-size: 11px; color: var(--text-secondary);">Type: </span>
                  <span id="category-label" style="font-size: 12px; font-weight: 500; color: var(--text-primary);">Other</span>
                </div>
              </div>
              
              <button onclick="addTodo()" class="btn btn-primary" style="padding: 8px 16px; font-size: 14px; font-weight: 600; min-width: 60px; border-radius: 6px;">
                ‚ûï
              </button>
            </div>
            
            <div class="todo-filters" style="margin-bottom: 10px; display: flex; gap: 8px; align-items: center; flex-wrap: wrap;">
              <span style="font-size: 12px; margin-right: 4px;">Show:</span>
              
              <div style="display: flex; align-items: center; gap: 4px; padding: 4px 8px; background: var(--bg-tertiary); border-radius: 6px;">
                <label style="display: flex; align-items: center; gap: 4px; cursor: pointer; user-select: none;">
                  <input type="checkbox" id="filter-pending" checked onchange="updateStatusFilters()" style="cursor: pointer;">
                  <span style="font-size: 12px;">üî¥ Pending</span>
                </label>
                <select id="date-range-pending" onchange="updateStatusFilters()" style="font-size: 11px; padding: 2px 4px; background: var(--bg-primary); color: var(--text-primary); border: 1px solid var(--border); border-radius: 4px;">
                  <option value="all">All time</option>
                  <option value="24h">Last 24h</option>
                  <option value="48h">Last 48h</option>
                  <option value="7d">Last 7 days</option>
                  <option value="30d">Last 30 days</option>
                  <option value="custom">Custom...</option>
                </select>
              </div>
              
              <div style="display: flex; align-items: center; gap: 4px; padding: 4px 8px; background: var(--bg-tertiary); border-radius: 6px;">
                <label style="display: flex; align-items: center; gap: 4px; cursor: pointer; user-select: none;">
                  <input type="checkbox" id="filter-in-progress" checked onchange="updateStatusFilters()" style="cursor: pointer;">
                  <span style="font-size: 12px;">‚è≥ In Progress</span>
                </label>
                <select id="date-range-in_progress" onchange="updateStatusFilters()" style="font-size: 11px; padding: 2px 4px; background: var(--bg-primary); color: var(--text-primary); border: 1px solid var(--border); border-radius: 4px;">
                  <option value="all">All time</option>
                  <option value="24h">Last 24h</option>
                  <option value="48h">Last 48h</option>
                  <option value="7d">Last 7 days</option>
                  <option value="30d">Last 30 days</option>
                  <option value="custom">Custom...</option>
                </select>
              </div>
              
              <div style="display: flex; align-items: center; gap: 4px; padding: 4px 8px; background: var(--bg-tertiary); border-radius: 6px;">
                <label style="display: flex; align-items: center; gap: 4px; cursor: pointer; user-select: none;">
                  <input type="checkbox" id="filter-claude-done" checked onchange="updateStatusFilters()" style="cursor: pointer;">
                  <span style="font-size: 12px;">üü° Awaiting Review</span>
                </label>
                <select id="date-range-claude_done" onchange="updateStatusFilters()" style="font-size: 11px; padding: 2px 4px; background: var(--bg-primary); color: var(--text-primary); border: 1px solid var(--border); border-radius: 4px;">
                  <option value="all">All time</option>
                  <option value="24h">Last 24h</option>
                  <option value="48h">Last 48h</option>
                  <option value="7d">Last 7 days</option>
                  <option value="30d">Last 30 days</option>
                  <option value="custom">Custom...</option>
                </select>
              </div>
              
              <div style="display: flex; align-items: center; gap: 4px; padding: 4px 8px; background: var(--bg-tertiary); border-radius: 6px;">
                <label style="display: flex; align-items: center; gap: 4px; cursor: pointer; user-select: none;">
                  <input type="checkbox" id="filter-approved" onchange="updateStatusFilters()" style="cursor: pointer;">
                  <span style="font-size: 12px;">üü¢ Completed</span>
                </label>
                <select id="date-range-user_approved" onchange="updateStatusFilters()" style="font-size: 11px; padding: 2px 4px; background: var(--bg-primary); color: var(--text-primary); border: 1px solid var(--border); border-radius: 4px;">
                  <option value="all">All time</option>
                  <option value="24h">Last 24h</option>
                  <option value="48h" selected>Last 48h</option>
                  <option value="7d">Last 7 days</option>
                  <option value="30d">Last 30 days</option>
                  <option value="custom">Custom...</option>
                </select>
              </div>
              
              <div style="width: 1px; height: 20px; background: var(--border-color); margin: 0 4px;"></div>
              
              <button onclick="exportTodos()" class="btn btn-sm btn-secondary" title="Export as Markdown">üìÑ</button>
              <button onclick="refreshTodos()" class="btn btn-sm btn-secondary" title="Refresh">üîÑ</button>
              <button onclick="manageProjects()" class="btn btn-sm btn-secondary" title="Manage Projects">üìÅ</button>
              <button onclick="fixAndResetHierarchy()" class="btn btn-sm btn-secondary" title="Fix Hierarchy">üîß</button>
            </div>
            
            <!-- Bulk actions bar - hidden by default -->
            <div id="bulk-actions-bar" style="display: none; padding: 8px; background: var(--bg-tertiary); border-bottom: 1px solid var(--border-color); align-items: center; gap: 8px;">
              <span style="font-size: 12px; color: var(--text-secondary);">
                <span id="selected-count">0</span> selected
              </span>
              <button onclick="clearSelection()" class="btn btn-sm" style="padding: 2px 8px; font-size: 11px;">Clear</button>
              <div style="flex: 1;"></div>
              <select id="bulk-action-select" class="btn btn-sm" style="padding: 2px 8px; font-size: 11px;">
                <option value="">Bulk Actions...</option>
                <option value="delete">Delete Selected</option>
                <option value="mark-done">Mark as Done</option>
                <option value="mark-approved">Mark as Approved</option>
                <option value="move-project">Move to Project...</option>
              </select>
              <button onclick="executeBulkAction()" class="btn btn-sm btn-primary" style="padding: 2px 8px; font-size: 11px;">Apply</button>
            </div>
            
            <div id="todo-list">
              <!-- Todo items will be rendered here -->
            </div>
            </div> <!-- End todo-main-container -->
          </div>
        </div>

      </div>
    </div>

    <!-- Modal for Schedule Editor -->
    <div id="schedule-modal" class="modal" style="display: none;">
      <div class="modal-content">
        <div class="modal-header">
          <h2>Schedule Configuration</h2>
          <span class="close" onclick="closeScheduleModal()">&times;</span>
        </div>
        <div class="modal-body">
          <!-- Schedule form will be populated here -->
        </div>
      </div>
    </div>
  </div>

  <!-- Include external scripts -->
  <script src="/dashboard-utils.js"></script>
  <script src="/dashboard-api.js"></script>
  <script src="/dashboard-schedule.js"></script>
  <script src="/dashboard-conditional.js"></script>
  <script src="/dashboard-conversations.js"></script>
  <script src="/dashboard-native-todos.js"></script>
  <script src="/dashboard-chat.js"></script>
  <script src="/dashboard-tmux-status.js"></script>
  <script src="/session-state.js"></script>

  <!-- Initialize dashboard -->
  <script>
    // Add comprehensive error logging
    window.onerror = function(msg, url, lineNo, columnNo, error) {
      console.error('Global error caught:', {
        message: msg,
        source: url,
        line: lineNo,
        column: columnNo,
        error: error
      });
      // Send to backend for logging
      if (window.dashboardAPI) {
        dashboardAPI.post('/api/client-error', {
          message: msg,
          source: url,
          line: lineNo,
          column: columnNo,
          stack: error?.stack
        }).catch(() => {}); // Silent fail if API not available
      }
      return false; // Let default error handling continue
    };

    window.addEventListener('unhandledrejection', function(event) {
      console.error('Unhandled promise rejection:', event.reason);
      if (window.dashboardAPI) {
        dashboardAPI.post('/api/client-error', {
          message: 'Unhandled promise rejection',
          reason: event.reason?.toString(),
          stack: event.reason?.stack
        }).catch(() => {});
      }
    });

    // Track script loading
    const scriptLoadStatus = {
      'dashboard-api': false,
      'dashboard-utils': false,
      'dashboard-main': false,
      'dashboard-schedule': false,
      'dashboard-conditional': false,
      'dashboard-conversations': false,
      'dashboard-chat': false,
      'dashboard-tmux-status': false,
      'session-state': false
    };

    // Global state - currentSession managed by sessionState
    let currentSession = null; // Will be set after loading sessions
    let loopConfig = {};
    window.loopConfig = loopConfig; // Make it globally accessible

    // Per-session state cache - persists context, prompts, and monitoring data
    // Structure: { sessionId: { percent, timestamp, interactivePrompt: { detected, type, content, timestamp }, lastUpdate } }
    let sessionContextCache = {};
    // Load from localStorage on startup
    try {
      const stored = localStorage.getItem('sessionContextCache');
      if (stored) {
        sessionContextCache = JSON.parse(stored);
      }
    } catch (e) {
      console.error('Failed to load context cache:', e);
    }

    // Helper function to update session state in cache
    function updateSessionState(sessionId, updates) {
      if (!sessionContextCache[sessionId]) {
        sessionContextCache[sessionId] = {};
      }

      // Check if anything actually changed
      const oldState = JSON.stringify(sessionContextCache[sessionId]);
      Object.assign(sessionContextCache[sessionId], updates);
      sessionContextCache[sessionId].lastUpdate = Date.now();
      const newState = JSON.stringify(sessionContextCache[sessionId]);

      // Only write to localStorage if state changed
      if (oldState !== newState) {
        try {
          localStorage.setItem('sessionContextCache', JSON.stringify(sessionContextCache));
          console.debug(`[Session State] Updated cache for ${sessionId}`);
        } catch (e) {
          console.error('Failed to save session state cache:', e);
        }
      }
    }

    // Helper function to get session state from cache
    function getSessionState(sessionId) {
      return sessionContextCache[sessionId] || {
        percent: null,
        timestamp: null,
        interactivePrompt: null,
        lastUpdate: null,
        // Tiered monitoring fields
        lastChanged: null,              // When content last changed
        lastViewed: Date.now(),          // When user last clicked tab (default to now)
        lastRefreshed: null,            // Last background refresh
        lastContent: null,              // Hash of last content for change detection
        tier: 'active',                 // Current monitoring tier
        consecutiveNoChanges: 0,        // Count refreshes with no changes
        // Message timestamp tracking
        lastManualMessageTime: null     // When last manual message was sent
      };
    }

    // Calculate monitoring tier based on activity
    function calculateMonitoringTier(session) {
      const state = getSessionState(session);
      const now = Date.now();

      // Dormant: manually paused - never monitor
      if (state.monitoringPaused) {
        return 'dormant';
      }

      const timeSinceChange = now - (state.lastChanged || now);
      const timeSinceViewed = now - (state.lastViewed || now);

      // Active: Recent change OR recent view OR pending prompt
      if (timeSinceChange < 5 * 60 * 1000 ||
          timeSinceViewed < 5 * 60 * 1000 ||
          (state.interactivePrompt && state.interactivePrompt.detected)) {
        return 'active';
      }

      // Idle: Some recent activity (changed in last 15 min)
      if (timeSinceChange < 15 * 60 * 1000) {
        return 'idle';
      }

      // Passive: Long idle time
      return 'passive';
    }

    // Background session monitoring queue
    let backgroundSessionQueue = [];
    let backgroundQueueIndex = 0;

    // Update the queue of sessions that need background monitoring (tier-aware)
    function updateBackgroundSessionQueue() {
      const sessionTabs = document.querySelectorAll('.session-tab');
      const allSessions = Array.from(sessionTabs)
        .map(tab => tab.getAttribute('data-session'))
        .filter(Boolean)
        .filter(session => session !== currentSession); // Exclude current session

      // Separate sessions by tier
      const activeSessions = [];
      const idleSessions = [];
      const passiveSessions = [];
      const dormantSessions = [];

      allSessions.forEach(session => {
        const tier = calculateMonitoringTier(session);

        switch (tier) {
          case 'active':
            activeSessions.push(session);
            break;
          case 'idle':
            idleSessions.push(session);
            break;
          case 'passive':
            passiveSessions.push(session);
            break;
          case 'dormant':
            dormantSessions.push(session);
            break;
        }
      });

      // Build queue: active sessions first, then idle
      // Passive and dormant excluded from background monitoring
      const newQueue = [...activeSessions, ...idleSessions];

      // Only update queue if it changed
      const queueChanged = JSON.stringify(backgroundSessionQueue) !== JSON.stringify(newQueue);
      if (queueChanged) {
        backgroundSessionQueue = newQueue;
        backgroundQueueIndex = 0; // Reset to start
        console.debug(`[Tier Queue] Active: ${activeSessions.length}, Idle: ${idleSessions.length}, Passive: ${passiveSessions.length}, Dormant: ${dormantSessions.length}`);
      }
    }

    // Get next batch of sessions to refresh (rotating queue)
    function getNextBackgroundBatch(batchSize = 2) {
      if (backgroundSessionQueue.length === 0) {
        return [];
      }

      const batch = [];
      for (let i = 0; i < batchSize && backgroundSessionQueue.length > 0; i++) {
        batch.push(backgroundSessionQueue[backgroundQueueIndex]);
        backgroundQueueIndex = (backgroundQueueIndex + 1) % backgroundSessionQueue.length;
      }

      return batch;
    }

    let contextInterval = null;
    let logInterval = null;
    let currentTab = 'tmux'; // Track current active tab
    
    // Smooth countdown timer state
    let nextMessageTargetTime = null; // Store the target time for countdown
    let isPaused = false;
    let pausedTimeRemaining = 0;
    
    // Idle detection for CPU optimization
    let lastUserActivity = Date.now();
    let isPageVisible = !document.hidden; // Check actual visibility state on load
    let isUserIdle = false;
    const IDLE_THRESHOLD_MS = 5 * 60 * 1000; // 5 minutes of no activity = idle
    let nextRefreshTimeout = null; // Single timeout for event-driven refresh
    let isLoopRunning = false; // Track if auto-loop is active for this session
    
    // Multi-select state for todos
    let selectedTodos = new Set();
    let lastSelectedTodo = null; // Track last selected for shift-click range

    // Initialize schedule minutes globally (default to null, will be loaded from config)
    window.scheduleMinutes = null;

    // Define switchTab early so it's available for onclick handlers
    window.switchTab = function(tab) {
      try {
        currentTab = tab;
        
        // Save tab preference to localStorage
        localStorage.setItem('preferred-tab', tab);

        // Update tab buttons
        document.querySelectorAll('.tab-button').forEach(btn => {
          btn.classList.remove('active');
        });
        const tabBtn = document.getElementById(`${tab}-tab`);
        if (tabBtn) tabBtn.classList.add('active');

        // Update tab panels
        document.querySelectorAll('.tab-panel').forEach(panel => {
          panel.classList.remove('active');
          panel.style.display = 'none';
        });
        const tabPanel = document.getElementById(`${tab}-panel`);
        if (tabPanel) {
          tabPanel.classList.add('active');
          tabPanel.style.display = 'block';
        }

        // Update chat refresh interval based on new tab
        if (typeof updateChatRefresh === 'function') {
          updateChatRefresh();
        }
        
        // Refresh content for the active tab
        if (tab === 'chat' && window.dashboardChat) {
          window.dashboardChat.refresh();
        } else if (tab === 'tmux' && typeof refreshTmux === 'function') {
          refreshTmux();
          // Restart scheduling when switching to tmux tab
          scheduleNextRefresh();
        }
      } catch (error) {
        console.error('Error switching tab:', error);
      }
    }

    // Font size control for chat
    window.updateChatFontSize = function () {
      const select = document.getElementById('chat-font-size');
      if (!select) return;

      const fontSize = select.value + 'px';

      // Update all message bubbles
      const style = document.createElement('style');
      style.id = 'chat-font-size-override';

      // Remove existing override if present
      const existing = document.getElementById('chat-font-size-override');
      if (existing) {
        existing.remove();
      }

      style.innerHTML = `
        .message-bubble {
          font-size: ${fontSize} !important;
        }
        .message-timestamp {
          font-size: ${parseInt(select.value) - 2}px !important;
        }
        .message-bubble code {
          font-size: ${parseInt(select.value) - 1}px !important;
        }
        .message-bubble pre {
          font-size: ${parseInt(select.value) - 1}px !important;
        }
      `;

      document.head.appendChild(style);

      // Save preference
      localStorage.setItem('chat-font-size', select.value);
    };

    // Height control removed - tmux panel is now resizable via CSS resize: vertical

    // Event-driven refresh system - no polling!
    let baseRefreshRate = 5000; // Default 5 seconds
    
    // Calculate the appropriate refresh delay based on current state
    function calculateRefreshDelay() {
      // If manually paused, stop
      if (baseRefreshRate === 0) return 0;
      
      // If tmux tab is active and page visible, use user's selected rate
      if (currentTab === 'tmux' && isPageVisible) {
        return baseRefreshRate; // Whatever user selected
      }
      
      // Background refresh logic when loop is running OR auto-accept without loop is enabled
      const autoAcceptWithoutLoop = loopConfig.autoAcceptWithoutLoop === true;
      if (isLoopRunning || autoAcceptWithoutLoop) {
        // Use 10s OR user's rate, whichever is SLOWER
        return Math.max(10000, baseRefreshRate);
      }
      
      // No loop running, user is idle - stop completely to save CPU
      if (isUserIdle) {
        return 0;
      }
      
      // Background, no loop - use 20s OR user's rate, whichever is SLOWER
      return Math.max(20000, baseRefreshRate);
    }
    
    // Update the visual indicator showing current refresh state
    function updateRefreshIndicator(delay) {
      const indicator = document.getElementById('refresh-indicator');
      if (!indicator) return;
      
      if (delay === 0 && baseRefreshRate === 0) {
        indicator.textContent = '‚è∏ Paused';
      } else if (delay === 0) {
        indicator.textContent = 'üò¥ Idle';
      } else if (currentTab === 'tmux' && isPageVisible) {
        // Active tab - show user's selected rate
        const seconds = baseRefreshRate / 1000;
        indicator.textContent = `üîÑ ${seconds}s`;
      } else if (isLoopRunning) {
        const seconds = delay / 1000;
        indicator.textContent = `üîÑ ${seconds}s (loop)`;
      } else {
        const seconds = delay / 1000;
        indicator.textContent = `üîÑ ${seconds}s (bg)`;
      }
    }
    
    // Schedule the next refresh using timeout instead of interval
    function scheduleNextRefresh() {
      // Clear any existing timeout
      if (nextRefreshTimeout) {
        clearTimeout(nextRefreshTimeout);
        nextRefreshTimeout = null;
      }
      
      // Calculate delay based on current state
      const delay = calculateRefreshDelay();
      updateRefreshIndicator(delay);
      
      // If delay is 0, we're idle - stop scheduling
      if (delay === 0) {
        console.debug('[CPU Optimization] Stopping refresh - idle or paused');
        return;
      }
      
      // Schedule the next refresh
      nextRefreshTimeout = setTimeout(async () => {
        // Foreground: Full refresh with DOM updates for active session
        if (currentTab === 'tmux' && currentSession) {
          await refreshTmux().catch(err => {
            console.debug('[CPU Optimization] Refresh error:', err);
          });
        }

        // Background: Efficient rotating queue for monitoring other sessions
        // Update queue to reflect current sessions
        updateBackgroundSessionQueue();

        // Get next small batch (2 sessions per cycle = efficient rotation)
        const backgroundBatch = getNextBackgroundBatch(2);

        if (backgroundBatch.length > 0) {
          // Refresh batch in parallel (only 2 at a time, not all 22!)
          await Promise.all(backgroundBatch.map(session =>
            refreshTmuxBackground(session).catch(err => {
              console.debug(`[Background Refresh] Error for ${session}:`, err);
            })
          ));
          console.debug(`[Background Queue] Refreshed batch:`, backgroundBatch);
        }

        // Chain the next timeout
        scheduleNextRefresh();
      }, delay);
      
      console.debug(`[CPU Optimization] Next refresh in ${delay}ms`);
    }
    
    // Handle refresh rate changes from dropdown
    window.updateTmuxRefreshRate = function () {
      const select = document.getElementById('tmux-refresh-rate');
      if (!select) return;

      baseRefreshRate = parseInt(select.value);

      // Save preference
      localStorage.setItem('tmux-refresh-rate', select.value);

      // Update indicator immediately
      updateRefreshIndicator(calculateRefreshDelay());

      // Restart scheduling with new rate
      scheduleNextRefresh();

      // If switching from paused to active, do immediate refresh
      if (baseRefreshRate > 0 && currentTab === 'tmux' && currentSession) {
        refreshTmux().catch(err => {
          console.debug('[CPU Optimization] Initial refresh error:', err);
        });
      }
    }

    // Handle monitoring mode toggle
    window.updateMonitoringMode = function () {
      const checkbox = document.getElementById('monitor-all-tabs');
      if (!checkbox) return;

      // Save preference
      localStorage.setItem('monitor-all-tabs', checkbox.checked.toString());

      // Update queue immediately - queue will be rebuilt on next refresh cycle
      console.log(`[Background Monitoring] Mode changed to: ${checkbox.checked ? 'All Tabs' : 'Smart Mode (auto-accept/loop only)'}`);

      // Force immediate queue update
      updateBackgroundSessionQueue();
    }

    // Font size control for tmux
    window.updateTmuxFontSize = function () {
      const select = document.getElementById('tmux-font-size');
      if (!select) return;

      const fontSize = select.value + 'px';

      // Update tmux content font size
      const style = document.createElement('style');
      style.id = 'tmux-font-size-override';

      // Remove existing override if present
      const existing = document.getElementById('tmux-font-size-override');
      if (existing) {
        existing.remove();
      }

      style.innerHTML = `
        #tmux-content {
          font-size: ${fontSize} !important;
          line-height: 1.4 !important;
        }
        #tmux-content pre {
          font-size: ${fontSize} !important;
        }
        #tmux-content .ansi-line {
          font-size: ${fontSize} !important;
        }
        #tmux-status-content {
          font-size: ${fontSize} !important;
          line-height: 1.4 !important;
        }
        #tmux-status-content pre {
          font-size: ${fontSize} !important;
        }
      `;

      document.head.appendChild(style);

      // Save preference
      localStorage.setItem('tmux-font-size', select.value);
    };

    // Multi-tab detection
    let tabId = Date.now() + '-' + Math.random();
    let heartbeatInterval;
    
    function detectMultipleTabs() {
      // Store our tab ID with timestamp
      localStorage.setItem('dashboard-tab-' + tabId, Date.now());
      
      // Check for other tabs
      let activeTabs = 0;
      for (let key in localStorage) {
        if (key.startsWith('dashboard-tab-')) {
          const timestamp = parseInt(localStorage.getItem(key));
          // Consider tab active if heartbeat within last 10 seconds
          if (Date.now() - timestamp < 10000) {
            activeTabs++;
          } else {
            // Clean up old tab entries
            localStorage.removeItem(key);
          }
        }
      }
      
      // Warn if multiple tabs detected
      const statusDiv = document.getElementById('status');
      if (activeTabs > 1 && statusDiv) {
        const warning = `<div style="background: #ff6b6b; color: white; padding: 5px 10px; margin: 5px 0; border-radius: 4px;">
          ‚ö†Ô∏è Multiple dashboard tabs detected (${activeTabs} tabs). This causes high CPU usage. Please close other tabs.
        </div>`;
        if (!statusDiv.innerHTML.includes('Multiple dashboard tabs')) {
          statusDiv.innerHTML = warning + statusDiv.innerHTML;
        }
      }
    }
    
    // Initialize on load
    // Textarea height management
    function initTextareaHeightManagement() {
      const textarea = document.getElementById('custom-message');
      if (!textarea) return;

      // Load saved height preference
      const savedHeight = localStorage.getItem('textarea-preferred-height');
      const defaultHeight = 80; // 4 rows worth
      const preferredHeight = savedHeight ? parseInt(savedHeight) : defaultHeight;
      
      // Set initial height
      textarea.style.height = preferredHeight + 'px';
      
      // Track if user has manually resized
      let userResized = false;
      let lastManualHeight = preferredHeight;
      
      // Detect manual resize via mouse
      textarea.addEventListener('mouseup', () => {
        const currentHeight = textarea.offsetHeight;
        if (Math.abs(currentHeight - lastManualHeight) > 5) {
          userResized = true;
          lastManualHeight = currentHeight;
          localStorage.setItem('textarea-preferred-height', currentHeight);
        }
      });
      
      // Track the last known height to avoid unnecessary resizing
      let lastKnownHeight = preferredHeight;
      
      // Auto-resize on input
      textarea.addEventListener('input', () => {
        const currentText = textarea.value;
        const isEmpty = currentText.trim() === '';
        
        if (isEmpty) {
          // Only resize to preferred height if we're truly empty and not already at preferred height
          const currentPreferredHeight = parseInt(localStorage.getItem('textarea-preferred-height') || '80');
          if (Math.abs(textarea.offsetHeight - currentPreferredHeight) > 5) {
            textarea.style.height = currentPreferredHeight + 'px';
            lastKnownHeight = currentPreferredHeight;
          }
        } else {
          // Calculate needed height for content
          const currentHeight = textarea.offsetHeight;
          
          // Temporarily set to auto to measure needed height
          textarea.style.height = 'auto';
          const neededHeight = textarea.scrollHeight;
          
          // Determine final height
          const maxHeight = 400;
          const minHeight = parseInt(localStorage.getItem('textarea-preferred-height') || '80');
          const targetHeight = Math.max(minHeight, Math.min(neededHeight, maxHeight));
          
          // Only resize if there's a significant change
          if (Math.abs(currentHeight - targetHeight) > 5) {
            textarea.style.height = targetHeight + 'px';
            lastKnownHeight = targetHeight;
          } else {
            // Restore the current height if no significant change needed
            textarea.style.height = currentHeight + 'px';
          }
        }
      });
      
      // Also save height when focus is lost
      textarea.addEventListener('blur', () => {
        if (userResized) {
          const currentHeight = textarea.offsetHeight;
          localStorage.setItem('textarea-preferred-height', currentHeight);
        }
      });
    }

    document.addEventListener('DOMContentLoaded', async () => {
      console.log('Initializing dashboard...');

      // Load sidebar collapse state
      loadSidebarState();

      // Start multi-tab detection
      heartbeatInterval = setInterval(detectMultipleTabs, 5000);
      detectMultipleTabs(); // Initial check

      // Clean up on unload
      window.addEventListener('beforeunload', () => {
        localStorage.removeItem('dashboard-tab-' + tabId);
        if (heartbeatInterval) clearInterval(heartbeatInterval);
        if (nextRefreshTimeout) clearTimeout(nextRefreshTimeout);
      });

      // Load sessions
      await loadSessions();

      // Load initial config
      await loadConfig();

      // Initialize textarea height management
      initTextareaHeightManagement();

      // Initialize conditional messaging module
      if (window.dashboardConditional) {
        dashboardConditional.init();
      }

      // Initialize idle detection FIRST (sets up event listeners)
      setupIdleDetection();

      // Enable horizontal mouse wheel scrolling for session tabs
      const sessionTabsContainer = document.getElementById('session-tabs-container');
      if (sessionTabsContainer) {
        sessionTabsContainer.addEventListener('wheel', (e) => {
          // Only convert to horizontal scroll if scrolling vertically
          if (e.deltaY !== 0 && sessionTabsContainer.scrollWidth > sessionTabsContainer.clientWidth) {
            e.preventDefault();
            sessionTabsContainer.scrollLeft += e.deltaY;
          }
        }, { passive: false });
      }

      // Add keyboard shortcuts for cycling through sessions
      document.addEventListener('keydown', (e) => {
        // Ctrl + ` (backtick) - cycle forward
        // Ctrl + Shift + ` - cycle backward
        if (e.ctrlKey && e.key === '`') {
          e.preventDefault();
          cycleSession(e.shiftKey ? -1 : 1);
        }
      });

      // Start monitoring
      startMonitoring();
      
      // Initial countdown display
      updateCountdownDisplay();

      // Theme management
      updateTheme();

      // Listen for browser theme changes
      if (window.matchMedia) {
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
          const themeMode = localStorage.getItem('themeMode');
          if (!themeMode || themeMode === 'auto') {
            updateTheme();
          }
        });
      }

      // Restore saved font size preference for chat
      const savedChatFontSize = localStorage.getItem('chat-font-size');
      if (savedChatFontSize) {
        const select = document.getElementById('chat-font-size');
        if (select) {
          select.value = savedChatFontSize;
          updateChatFontSize();
        }
      }

      // Restore saved font size preference for tmux
      const savedTmuxFontSize = localStorage.getItem('tmux-font-size');
      if (savedTmuxFontSize) {
        const select = document.getElementById('tmux-font-size');
        if (select) {
          select.value = savedTmuxFontSize;
          updateTmuxFontSize();
        }
      }

      // Tmux height is now resizable via CSS resize: vertical

      // Restore saved refresh rate preference for tmux
      const savedTmuxRefreshRate = localStorage.getItem('tmux-refresh-rate');
      if (savedTmuxRefreshRate) {
        const select = document.getElementById('tmux-refresh-rate');
        if (select) {
          select.value = savedTmuxRefreshRate;
          baseRefreshRate = parseInt(savedTmuxRefreshRate);
        }
      }

      // Restore saved monitoring mode preference
      const savedMonitoringMode = localStorage.getItem('monitor-all-tabs');
      if (savedMonitoringMode !== null) {
        const checkbox = document.getElementById('monitor-all-tabs');
        if (checkbox) {
          checkbox.checked = savedMonitoringMode === 'true';
        }
      }
      
      // Start the event-driven refresh system after a small delay to ensure everything is initialized
      setTimeout(() => {
        console.log('[CPU Optimization] Starting event-driven refresh system');
        scheduleNextRefresh();
      }, 100);
    });

    // Update session tabs with active sessions
    function updateSessionTabs(sessionsWithNames) {
      const tabsContainer = document.getElementById('session-tabs-container');
      const tabsDiv = document.getElementById('session-tabs');
      
      // Get running tmux sessions (using the same data as the dropdown)
      // Filter to only show claude-loop sessions that are actually running
      const runningSessions = sessionsWithNames.filter(s => 
        s.isRunning && s.id.startsWith('claude-loop')
      );
      
      // Only show tabs if there are running sessions
      if (runningSessions.length > 0) {
        tabsContainer.style.display = 'block';
        
        // Clear existing tabs
        tabsDiv.innerHTML = '';
        
        // Sort running sessions numerically
        runningSessions.sort((a, b) => {
          const getNum = (session) => {
            const match = session.id.match(/(\d+)$/);
            return match ? parseInt(match[1]) : Infinity;
          };
          return getNum(a) - getNum(b);
        });
        
        // Create tabs for each running session
        runningSessions.forEach(session => {
          const tab = document.createElement('button');
          tab.className = 'session-tab';
          
          // Add running class for visual indicator (dot)
          tab.classList.add('running');
          
          // Add active class if this is the current session
          if (session.id === currentSession) {
            tab.classList.add('active');
          }
          
          // Extract session number for display
          const sessionNum = session.id.match(/(\d+)$/)?.[1] || session.id;
          
          // Create tab content
          if (session.name && session.name !== session.id) {
            // Has custom name
            tab.innerHTML = `
              <div>
                <div class="session-tab-label">${session.name}</div>
                <div class="session-tab-number">Loop ${sessionNum}</div>
              </div>
              <span class="right-click-hint">‚ãÆ</span>
            `;
          } else {
            // No custom name, just show number
            tab.innerHTML = `
              <div class="session-tab-number">Loop ${sessionNum}</div>
              <span class="right-click-hint">‚ãÆ</span>
            `;
          }
          
          // Add data attribute for easy identification
          tab.setAttribute('data-session', session.id);
          tab.setAttribute('title', `${session.id} - Right-click for options`);

          // Add click handler
          tab.onclick = () => selectSession(session.id);

          // Add right-click handler for context menu
          tab.oncontextmenu = (e) => {
            return showSessionContextMenu(e, session.id);
          };
          
          tabsDiv.appendChild(tab);
        });
      } else {
        // Hide tabs if no running sessions
        tabsContainer.style.display = 'none';
      }
    }
    
    // Session management
    async function loadSessions() {
      try {
        const response = await dashboardAPI.getTmuxSessions();
        const sessions = response.sessions || [];
        const sessionsWithNames = response.sessionsWithNames || [];
        const select = document.getElementById('session-select');

        // Sort sessions numerically (claude-loop1, claude-loop2, ..., claude-loop10, claude-loop100)
        const sortNumerically = (a, b) => {
          // Extract numbers from session names
          const getNum = (str) => {
            const match = str.match(/(\d+)$/);
            return match ? parseInt(match[1]) : Infinity;
          };
          
          const aNum = getNum(typeof a === 'string' ? a : a.id);
          const bNum = getNum(typeof b === 'string' ? b : b.id);
          
          // If both have numbers, sort numerically
          if (aNum !== Infinity && bNum !== Infinity) {
            return aNum - bNum;
          }
          
          // Otherwise sort alphabetically
          const aStr = typeof a === 'string' ? a : a.id;
          const bStr = typeof b === 'string' ? b : b.id;
          return aStr.localeCompare(bStr);
        };
        
        // Sort the arrays
        sessions.sort(sortNumerically);
        sessionsWithNames.sort(sortNumerically);

        // Initialize session state with available sessions
        currentSession = await window.sessionState.initialize(sessions);
        
        // Update session tabs AFTER currentSession is set
        updateSessionTabs(sessionsWithNames);

        select.innerHTML = '';
        if (sessions.length > 0) {
          // Use enhanced format if available
          if (sessionsWithNames.length > 0) {
            sessionsWithNames.forEach(session => {
              const option = document.createElement('option');
              option.value = session.id;
              const statusIcon = session.isRunning ? ' ‚óè' : ' ‚óã';
              if (session.hasCustomName) {
                option.innerHTML = `<span class="session-custom-name">${session.name}</span> <span class="session-id">(${session.id})</span>`;
                option.textContent = `${session.name} (${session.id})${statusIcon}`;
              } else {
                option.textContent = session.id + statusIcon;
              }
              if (!session.isRunning) {
                option.style.color = '#999';
              }
              if (session.id === currentSession) {
                option.selected = true;
              }
              select.appendChild(option);
            });
          } else {
            // Fallback to simple format
            sessions.forEach(session => {
              const option = document.createElement('option');
              option.value = session;
              option.textContent = session;
              if (session === currentSession) {
                option.selected = true;
              }
              select.appendChild(option);
            });
          }

          // Make sure window.currentSession is set for other modules
          window.currentSession = currentSession;
        } else {
          select.innerHTML = '<option value="">No sessions found</option>';
          currentSession = null;
          window.currentSession = null;
        }
      } catch (error) {
        console.error('Failed to load sessions:', error);
      }
    }

    // Toggle legend visibility
    function toggleLegend() {
      const tooltip = document.getElementById('legend-tooltip');
      if (tooltip.style.display === 'none') {
        tooltip.style.display = 'block';
        // Close when clicking outside
        setTimeout(() => {
          document.addEventListener('click', function closeTooltip(e) {
            if (!tooltip.contains(e.target) && !e.target.classList.contains('legend-button')) {
              tooltip.style.display = 'none';
              document.removeEventListener('click', closeTooltip);
            }
          });
        }, 0);
      } else {
        tooltip.style.display = 'none';
      }
    }

    function cycleSession(direction = 1) {
      // Get all session options from the dropdown
      const sessionSelect = document.getElementById('session-select');
      if (!sessionSelect || sessionSelect.options.length === 0) return;

      const sessions = Array.from(sessionSelect.options).map(opt => opt.value);
      const currentIndex = sessions.indexOf(currentSession);

      if (currentIndex === -1) {
        // Current session not in list, select first
        selectSession(sessions[0]);
        return;
      }

      // Calculate next index with wrap-around
      let nextIndex = currentIndex + direction;
      if (nextIndex >= sessions.length) {
        nextIndex = 0; // Wrap to beginning
      } else if (nextIndex < 0) {
        nextIndex = sessions.length - 1; // Wrap to end
      }

      // Switch to the new session
      selectSession(sessions[nextIndex]);
    }

    async function selectSession(session) {
      // Use session state manager
      if (window.sessionState.setCurrentSession(session)) {
        currentSession = session;
        window.currentSession = session; // Keep global in sync

        // Load session-specific message history
        loadMessageHistory(session);

        // Load session-specific timestamp preference
        setupTimestampToggle(session);

        // Track that user viewed this session (for tiered monitoring)
        updateSessionState(session, {
          lastViewed: Date.now(),
          tier: 'active', // Clicking a tab promotes it to active tier
          consecutiveNoChanges: 0 // Reset no-change counter on user interaction
        });

        // Immediately restore context from cache for instant feedback
        const cachedState = getSessionState(session);
        if (cachedState.percent !== null) {
          updateContextDisplay(cachedState.percent);
          console.debug(`[Session Switch] Restored context ${cachedState.percent}% from cache for ${session}`);
        }

        // Restore pause button state for this session
        updatePauseButton();

        await loadConfig();
        await updateStatus();
        
        // Update active session tab
        document.querySelectorAll('.session-tab').forEach(tab => {
          tab.classList.remove('active');
          if (tab.getAttribute('data-session') === session) {
            tab.classList.add('active');
          }
        });

        // Update todo project dropdown to match current session
        const projectSelect = document.getElementById('new-todo-project');
        if (projectSelect) {
          // Check if this session exists as an option
          let hasSession = false;
          for (let option of projectSelect.options) {
            if (option.value === session) {
              hasSession = true;
              break;
            }
          }
          
          // If not, reinitialize the dropdowns to include it
          if (!hasSession) {
            todoProjects.add(session);
            initProjectDropdowns();
          }
          
          // Select the current session
          projectSelect.value = session;
          
          // Also update the filter to show this session's todos by default
          const projectFilter = document.getElementById('todo-project-filter');
          if (projectFilter) {
            // Ensure the session is in the filter dropdown
            let hasFilterOption = false;
            for (let option of projectFilter.options) {
              if (option.value === session) {
                hasFilterOption = true;
                break;
              }
            }
            
            // If not in filter, reload todos to get all projects then reinit dropdowns
            if (!hasFilterOption) {
              await loadTodos(); // This will rebuild todoProjects set
              initProjectDropdowns();
            }
            
            // Only auto-switch to session's todos if user hasn't manually selected a project recently
            const savedTime = localStorage.getItem('selected-todo-project-time');
            const minutesSinceSelection = savedTime ? (Date.now() - parseInt(savedTime)) / (1000 * 60) : Infinity;
            
            // If user manually selected a project in the last 10 minutes, keep their selection
            if (minutesSinceSelection > 10) {
              projectFilter.value = session;
              todoProjectFilter = session;
              renderTodos();
            }
          }
        }

        // Reload todos for the new session
        await loadTodos();
        
        // Clear the tmux display immediately when switching sessions
        const tmuxContent = document.getElementById('tmux-content');
        if (tmuxContent) {
          tmuxContent.innerHTML = '<div style="color: #666; padding: 10px;">Loading session ' + session + '...</div>';
        }
        
        // Update the conversations panel to show the correct current conversation
        if (window.dashboardConversations) {
          try {
            await dashboardConversations.autoSelectConversation();
          } catch (err) {
            console.error('Failed to auto-select conversation:', err);
          }
        }
        
        // Refresh the current tab content
        if (currentTab === 'chat') {
          // Try to auto-detect conversation for the new session
          await dashboardChat.onSessionSwitch();
        } else {
          await refreshTmux();
        }
        
        // Restart refresh scheduling with the new session
        scheduleNextRefresh();
      }
    }

    async function createNewSession() {
      // Auto-generate a unique session name
      // Find the next available claude-loop number (fills gaps or uses next highest)
      const sessions = Array.from(document.getElementById('session-select').options)
        .map(opt => opt.value);
      
      // Extract existing session numbers
      const existingNumbers = sessions
        .filter(s => s.startsWith('claude-loop'))
        .map(s => {
          const match = s.match(/claude-loop(\d+)/);
          return match ? parseInt(match[1]) : null;
        })
        .filter(n => n !== null)
        .sort((a, b) => a - b);
      
      let sessionNum;
      
      if (existingNumbers.length === 0) {
        // No sessions exist, start with 1
        sessionNum = 1;
      } else {
        // Look for gaps in the sequence
        sessionNum = null;
        for (let i = 1; i <= existingNumbers[existingNumbers.length - 1]; i++) {
          if (!existingNumbers.includes(i)) {
            sessionNum = i;
            break;
          }
        }
        
        // If no gaps found, use the next number after the highest
        if (sessionNum === null) {
          sessionNum = existingNumbers[existingNumbers.length - 1] + 1;
        }
      }
      
      const sanitizedName = `claude-loop${sessionNum}`;

      try {
        await dashboardAPI.createTmuxSession(sanitizedName);
        
        // Small delay to ensure tmux session is fully created
        await new Promise(resolve => setTimeout(resolve, 500));
        
        await loadSessions();
        
        // loadSessions already updates sessionState with available sessions
        // Now set the new session as current
        currentSession = sanitizedName;
        window.currentSession = sanitizedName;
        window.sessionState.setCurrentSession(sanitizedName);
        document.getElementById('session-select').value = sanitizedName;
        await loadConfig();
        
        // Show success feedback
        const statusDiv = document.getElementById('status');
        if (statusDiv) {
          const originalContent = statusDiv.innerHTML;
          statusDiv.innerHTML = `<span style="color: #4CAF50;">‚úì Created session: ${sanitizedName}</span>`;
          setTimeout(() => {
            statusDiv.innerHTML = originalContent;
          }, 2000);
        }
      } catch (error) {
        alert('Failed to create session: ' + error.message);
      }
    }

    async function killCurrentSession() {
      if (!currentSession) {
        console.warn('No session selected');
        return;
      }

      if (!confirm(`Kill session '${currentSession}'?`)) return;

      try {
        await dashboardAPI.killTmuxSession(currentSession);
        await loadSessions();
      } catch (error) {
        alert('Failed to kill session: ' + error.message);
      }
    }

    async function renameSession() {
      // Get the current session name/custom name
      const currentName = loopConfig.customName || currentSession;
      const newName = prompt('Enter new name for session:', currentName);

      if (!newName || newName === currentName) return;

      // Save the custom name to config
      loopConfig.customName = newName;
      await saveConfig();

      // Update the session dropdown to show the new name
      const select = document.getElementById('session-select');
      const option = select.querySelector(`option[value="${currentSession}"]`);
      if (option) {
        option.textContent = `${newName} (${currentSession})`;
      }
    }
    
    async function deleteSession() {
      if (!currentSession) {
        alert('No session selected');
        return;
      }
      
      // Get information about what will be deleted
      let configSize = 'unknown';
      let conversationCount = 0;
      let conversationSize = 'unknown';
      
      try {
        // Get session info from backend
        const response = await fetch(`/api/sessions/${currentSession}/info`);
        if (response.ok) {
          const info = await response.json();
          configSize = info.configSize || 'unknown';
          conversationCount = info.conversationCount || 0;
          conversationSize = info.conversationSize || 'unknown';
        }
      } catch (e) {
        console.error('Could not get session info:', e);
      }
      
      // Build confirmation message
      let confirmMsg = `Delete session '${currentSession}'?\n\n`;
      confirmMsg += `This will permanently delete:\n`;
      confirmMsg += `‚úì Session configuration (loop-config-${currentSession}.json)\n`;
      confirmMsg += `‚úì Tmux session (if running)\n`;
      
      if (conversationCount > 0) {
        confirmMsg += `\nConversation logs:\n`;
        confirmMsg += `${conversationCount} files (${conversationSize})\n`;
        confirmMsg += `\nDelete conversation logs too? (OK = Yes, Cancel = Keep logs)`;
        
        const deleteConversations = confirm(confirmMsg);
        if (deleteConversations === null) return; // User cancelled
        
        // Second confirmation for destructive action
        const finalConfirm = confirm(`Are you SURE you want to permanently delete session '${currentSession}'?\n\nThis action cannot be undone!`);
        if (!finalConfirm) return;
        
        try {
          const response = await fetch(`/api/sessions/${currentSession}/delete`, {
            method: 'DELETE',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ deleteConversations })
          });
          
          if (response.ok) {
            const result = await response.json();

            // Switch to another session before refreshing
            const sessionsData = await dashboardAPI.getTmuxSessions();
            const sessions = sessionsData.sessions || [];
            const otherSession = sessions.find(s => (typeof s === 'string' ? s : s.id) !== currentSession);
            if (otherSession) {
              currentSession = otherSession;
              await selectSession(otherSession);
            }
            
            // Reload sessions list
            await loadSessions();
            
            alert(`Session '${result.session}' deleted successfully.\n${result.deletedFiles} files removed.`);
          } else {
            const error = await response.text();
            alert(`Failed to delete session: ${error}`);
          }
        } catch (error) {
          console.error('Failed to delete session:', error);
          alert('Failed to delete session: ' + error.message);
        }
      } else {
        // No conversations, simpler confirmation
        confirmMsg += `\nThis action cannot be undone!`;
        
        if (!confirm(confirmMsg)) return;
        
        try {
          const response = await fetch(`/api/sessions/${currentSession}/delete`, {
            method: 'DELETE',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ deleteConversations: false })
          });
          
          if (response.ok) {
            const result = await response.json();

            // Switch to another session before refreshing
            const sessionsData = await dashboardAPI.getTmuxSessions();
            const sessions = sessionsData.sessions || [];
            const otherSession = sessions.find(s => (typeof s === 'string' ? s : s.id) !== currentSession);
            if (otherSession) {
              currentSession = otherSession;
              await selectSession(otherSession);
            }
            
            // Reload sessions list
            await loadSessions();
            
            alert(`Session '${result.session}' deleted successfully.`);
          } else {
            const error = await response.text();
            alert(`Failed to delete session: ${error}`);
          }
        } catch (error) {
          console.error('Failed to delete session:', error);
          alert('Failed to delete session: ' + error.message);
        }
      }
    }

    // Helper: Find available session name with (copy) suffix
    async function findAvailableSessionName(baseName) {
      const sessions = Array.from(document.getElementById('session-select').options)
        .map(opt => opt.value);

      // Check if base name is available
      if (!sessions.includes(baseName)) {
        return baseName;
      }

      // Try (copy 2), (copy 3), etc.
      let counter = 2;
      while (sessions.includes(`${baseName.replace(' (copy)', '')} (copy ${counter})`)) {
        counter++;
      }

      return `${baseName.replace(' (copy)', '')} (copy ${counter})`;
    }

    // Fork session - create a copy with same conversation history
    async function forkSession(sourceSession) {
      sourceSession = sourceSession || currentSession;

      if (!sourceSession) {
        alert('No session selected to fork');
        return;
      }

      try {
        // Load source session config
        const config = await dashboardAPI.getConfig(sourceSession);
        const conversationId = config.conversationId;

        if (!conversationId) {
          alert('This session has no tracked conversation to fork.\n\nFork only works with sessions that have an active conversation.');
          return;
        }

        // Confirm fork
        const sourceName = config.customName || sourceSession;
        if (!confirm(`Fork "${sourceName}"?\n\nThis will create a new session with the same conversation history and settings.`)) {
          return;
        }

        // Find available new session number first
        const sessions = Array.from(document.getElementById('session-select').options)
          .map(opt => opt.value);

        const existingNumbers = sessions
          .filter(s => s.startsWith('claude-loop'))
          .map(s => {
            const match = s.match(/claude-loop(\d+)/);
            return match ? parseInt(match[1]) : null;
          })
          .filter(n => n !== null)
          .sort((a, b) => a - b);

        let newSessionNum;
        if (existingNumbers.length === 0) {
          newSessionNum = 1;
        } else {
          // Look for gaps
          newSessionNum = null;
          for (let i = 1; i <= existingNumbers[existingNumbers.length - 1]; i++) {
            if (!existingNumbers.includes(i)) {
              newSessionNum = i;
              break;
            }
          }
          if (newSessionNum === null) {
            newSessionNum = existingNumbers[existingNumbers.length - 1] + 1;
          }
        }

        const newSessionName = `claude-loop${newSessionNum}`;

        // Create the new tmux session
        await dashboardAPI.createTmuxSession(newSessionName);
        await new Promise(resolve => setTimeout(resolve, 500));

        // Send the fork command to tmux
        const forkCommand = `claude --resume ${conversationId} --fork-session`;
        console.log(`[Fork] Starting Claude with: ${forkCommand}`);
        await dashboardAPI.sendToTmux(forkCommand, newSessionName);

        // Give Claude time to initialize and fork
        console.log('[Fork] Waiting for Claude to initialize...');
        await new Promise(resolve => setTimeout(resolve, 3000));

        // Try to detect the new conversation ID
        let newConversationId = null;
        try {
          // Get working directory project name
          const workingDir = config.workingDirectory || '/home/michael';
          const projectName = workingDir.replace(/\//g, '-').replace(/^-/, '');

          console.log(`[Fork] Looking for new conversation in project: ${projectName}`);

          // Call backend to check for newest conversation file
          const response = await fetch(`/api/conversation/newest?project=${encodeURIComponent(projectName)}`);
          if (response.ok) {
            const data = await response.json();
            newConversationId = data.conversationId;
            console.log(`[Fork] Detected new conversation: ${newConversationId}`);
          }
        } catch (e) {
          console.error('[Fork] Failed to detect new conversation ID:', e);
        }

        // Find copy name for custom name
        const newCustomName = await findAvailableSessionName(sourceName + ' (copy)');

        // Save config for new session
        const newConfig = {
          ...config,
          conversationId: newConversationId, // May be null if detection failed
          customName: newCustomName,
          lastModified: new Date().toISOString()
        };

        await dashboardAPI.saveConfig(newConfig, newSessionName);

        // Reload sessions
        await loadSessions();

        // Show success message with switch option
        const switchToFork = confirm(
          `‚úì Forked successfully!\n\n` +
          `Source: ${sourceName}\n` +
          `Fork: ${newCustomName} (${newSessionName})\n\n` +
          (newConversationId ?
            `Conversation ID: ${newConversationId}\n\n` :
            `‚ö†Ô∏è Conversation ID not detected - you may need to manually track it\n\n`) +
          `Switch to the forked session now?`
        );

        if (switchToFork) {
          await selectSession(newSessionName);
        }

      } catch (error) {
        console.error('Failed to fork session:', error);
        alert('Failed to fork session: ' + error.message);
      }
    }

    // Show context menu for session tab right-click
    function showSessionContextMenu(event, sessionId) {
      event.preventDefault();

      // Remove any existing context menu
      const existingMenu = document.getElementById('session-context-menu');
      if (existingMenu) {
        existingMenu.remove();
      }

      // Create context menu
      const menu = document.createElement('div');
      menu.id = 'session-context-menu';
      menu.style.cssText = `
        position: fixed;
        left: ${event.clientX}px;
        top: ${event.clientY}px;
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        z-index: 10000;
        min-width: 150px;
      `;

      menu.innerHTML = `
        <button class="context-menu-item" onclick="forkSession('${sessionId}'); document.getElementById('session-context-menu').remove();">
          üìã Fork
        </button>
        <button class="context-menu-item" onclick="currentSession='${sessionId}'; window.currentSession='${sessionId}'; renameSession(); document.getElementById('session-context-menu').remove();">
          ‚úèÔ∏è Rename
        </button>
        <div style="border-top: 1px solid var(--border-color); margin: 4px 0;"></div>
        <button class="context-menu-item" onclick="document.getElementById('session-context-menu').remove();" style="color: var(--text-secondary);">
          ‚ùå Cancel
        </button>
      `;

      document.body.appendChild(menu);

      // Close menu when clicking outside
      const closeMenu = (e) => {
        if (!menu.contains(e.target)) {
          menu.remove();
          document.removeEventListener('click', closeMenu);
        }
      };
      setTimeout(() => document.addEventListener('click', closeMenu), 10);

      return false;
    }

    // Toggle session menu dropdown
    function toggleSessionMenu() {
      const menu = document.getElementById('session-menu');
      if (menu.style.display === 'none') {
        menu.style.display = 'block';
      } else {
        menu.style.display = 'none';
      }
    }
    
    // Close menu when clicking outside
    document.addEventListener('click', function(event) {
      const menu = document.getElementById('session-menu');
      const button = event.target.closest('button');
      
      // If clicking outside the menu and not on the toggle button
      if (menu && !menu.contains(event.target) && 
          (!button || !button.onclick || !button.onclick.toString().includes('toggleSessionMenu'))) {
        menu.style.display = 'none';
      }
    });

    // Loop control
    async function startOrResumeLoop() {
      try {
        const status = await dashboardAPI.getStatus(currentSession);
        // If paused, resume. Otherwise, start with config
        if (status.paused) {
          await dashboardAPI.sendControl('resume', currentSession);
        } else {
          // When starting fresh, send the config
          await dashboardAPI.post('/api/control', {
            action: 'start',
            session: currentSession,
            config: loopConfig
          });
        }
        await updateStatus();
      } catch (error) {
        console.error('Failed to start/resume loop:', error.message);
      }
    }

    // Track last loop stop click for double-click detection (panic stop)
    let lastLoopStopClickTime = 0;

    async function stopLoop() {
      try {
        const now = Date.now();
        const timeSinceLastClick = now - lastLoopStopClickTime;
        lastLoopStopClickTime = now;

        // Double-click detection (within 500ms = panic stop!)
        if (timeSinceLastClick < 500) {
          console.log('[Panic Stop] Double-click detected - triggering emergency stop');
          await panicStop();
          return;
        }

        // Normal loop stop
        await dashboardAPI.sendControl('stop', currentSession);
        await updateStatus();
      } catch (error) {
        console.error('Failed to stop loop:', error.message);
      }
    }

    async function panicStop() {
      try {
        // 1. Cancel any pending message sends
        const cancelResult = await dashboardAPI.request('/api/cancel-pending-messages', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ session: currentSession })
        });

        console.log(`[Panic Stop] Cancelled ${cancelResult.cancelled} pending message(s)`);

        // 2. Stop the loop
        await dashboardAPI.sendControl('stop', currentSession);

        // 3. Uncheck auto-accept settings
        const autoAcceptCheckbox = document.getElementById('auto-accept-prompts');
        const autoAcceptWithoutLoopCheckbox = document.getElementById('auto-accept-without-loop');

        if (autoAcceptCheckbox && autoAcceptCheckbox.checked) {
          autoAcceptCheckbox.checked = false;
          await updateAutoAcceptPrompts(false);
        }

        if (autoAcceptWithoutLoopCheckbox && autoAcceptWithoutLoopCheckbox.checked) {
          autoAcceptWithoutLoopCheckbox.checked = false;
          await updateAutoAcceptWithoutLoop(false);
        }

        // 4. Visual feedback
        const statusDiv = document.getElementById('status');
        if (statusDiv) {
          statusDiv.innerHTML = '<span style="color: #f44336; font-weight: bold;">‚ö†Ô∏è EMERGENCY STOP - All operations cancelled</span>';
          setTimeout(() => {
            updateStatus(); // Restore normal status display
          }, 3000);
        }

        // 5. Refresh display
        setTimeout(refreshTmux, 500);

        console.log('[Panic Stop] Emergency stop complete');
      } catch (error) {
        console.error('[Panic Stop] Error:', error);
        alert('Panic stop encountered an error: ' + error.message);
      }
    }

    async function pauseLoop() {
      try {
        await dashboardAPI.sendControl('pause', currentSession);
        await updateStatus();
      } catch (error) {
        console.error('Failed to pause loop:', error.message);
      }
    }

    async function stopAllLoops() {
      if (!confirm('Stop all running loops?')) return;

      try {
        await dashboardAPI.sendControl('stop-all-loops');
        await updateStatus();
      } catch (error) {
        alert('Failed to stop all loops: ' + error.message);
      }
    }

    async function stopAllSessions() {
      if (!confirm('Kill all tmux sessions? This will terminate everything!')) return;

      try {
        await dashboardAPI.sendControl('stop-all-sessions');
        await loadSessions();
      } catch (error) {
        alert('Failed to stop all sessions: ' + error.message);
      }
    }

    // Configuration
    async function loadConfig() {
      try {
        const config = await dashboardAPI.getConfig(currentSession);
        loopConfig = config;
        window.loopConfig = config; // Update global reference

        // Update UI
        document.getElementById('working-directory').value = config.workingDirectory || '';
        document.getElementById('delay-minutes').value = config.delayMinutes || 10;

        // Try to detect CWD from session if working directory is empty
        if (!config.workingDirectory) {
          detectSessionCwd();
        }
        document.getElementById('start-with-delay').checked = config.startWithDelay !== false;
        document.getElementById('auto-accept-prompts').checked = config.autoAcceptPrompts === true;
        document.getElementById('auto-accept-delay').value = config.autoAcceptDelay || 10;
        document.getElementById('auto-accept-cooldown').value = config.autoAcceptCooldown !== undefined ? config.autoAcceptCooldown : 5;
        document.getElementById('show-prompt-notifications').checked = config.showPromptNotifications !== false;
        document.getElementById('auto-accept-without-loop').checked = config.autoAcceptWithoutLoop === true;
        document.getElementById('message-send-delay').value = config.messageSendDelay || 5;
        document.getElementById('retry-enter-key').checked = config.retryEnterKey !== false;
        document.getElementById('enable-auto-compact').checked = config.enableAutoCompact === true;
        document.getElementById('auto-compact-threshold').value = config.autoCompactThreshold || 5;

        // Show/hide delay and cooldown containers based on auto-accept setting
        const delayContainer = document.getElementById('auto-accept-delay-container');
        if (delayContainer) {
          delayContainer.style.display = config.autoAcceptPrompts ? 'flex' : 'none';
        }
        const cooldownContainer = document.getElementById('auto-accept-cooldown-container');
        if (cooldownContainer) {
          cooldownContainer.style.display = config.autoAcceptPrompts ? 'flex' : 'none';
        }

        // Show/hide threshold container based on auto-compact setting
        const thresholdContainer = document.getElementById('auto-compact-threshold-container');
        if (thresholdContainer) {
          thresholdContainer.style.display = config.enableAutoCompact ? 'flex' : 'none';
        }

        // Load custom message - prefer localStorage draft over config
        const messageDraft = localStorage.getItem(`message-draft-${currentSession}`);
        const customMessageField = document.getElementById('custom-message');

        // Skip setting "cd.." - it's probably a bad default somewhere
        if (config.customMessage === 'cd..' || config.customMessage === 'cd ..') {
          customMessageField.value = messageDraft || '';
        } else {
          customMessageField.value = messageDraft || config.customMessage || '';
        }

        // Load saved tmux lines selection
        if (config.tmuxLines && document.getElementById('tmux-lines')) {
          document.getElementById('tmux-lines').value = config.tmuxLines;
        }

        // Load schedule if present, otherwise initialize to 24/7
        if (config.schedule && config.schedule.minutes && Array.isArray(config.schedule.minutes)) {
          window.scheduleMinutes = [...config.schedule.minutes];
        } else {
          // Initialize to 24/7 only if not already set
          if (!window.scheduleMinutes) {
            window.scheduleMinutes = new Array(1440).fill(true);
          }
        }

        // Update precision selector if present
        if (config.schedule && config.schedule.precision) {
          const precisionSelect = document.getElementById('schedule-precision');
          if (precisionSelect) {
            precisionSelect.value = config.schedule.precision;
          }
        }

        // Redraw timeline if schedule is visible
        const scheduleCard = document.getElementById('schedule-card');
        if (scheduleCard && !scheduleCard.classList.contains('collapsed')) {
          if (window.dashboardSchedule) {
            dashboardSchedule.initializeTimeline();
          }
        }

        // Load conditional messages if present
        if (config.conditionalMessages && window.dashboardConditional) {
          dashboardConditional.config = { ...dashboardConditional.defaultConfig, ...config.conditionalMessages };
          dashboardConditional.loadConfigIntoUI();
        }
      } catch (error) {
        console.error('Failed to load config:', error);
      }
    }

    async function updateDelay(minutes) {
      loopConfig.delayMinutes = parseInt(minutes);
      await saveConfig();
    }

    async function updateStartWithDelay(checked) {
      console.log('Updating startWithDelay to:', checked);
      loopConfig.startWithDelay = checked;
      await saveConfig();
      console.log('Config saved, startWithDelay is now:', loopConfig.startWithDelay);
    }

    async function updateAutoAcceptPrompts(checked) {
      console.log('Updating autoAcceptPrompts to:', checked);
      loopConfig.autoAcceptPrompts = checked;

      // Show/hide delay and cooldown settings based on checkbox
      const delayContainer = document.getElementById('auto-accept-delay-container');
      if (delayContainer) {
        delayContainer.style.display = checked ? 'flex' : 'none';
      }
      const cooldownContainer = document.getElementById('auto-accept-cooldown-container');
      if (cooldownContainer) {
        cooldownContainer.style.display = checked ? 'flex' : 'none';
      }

      await saveConfig();
      console.log('Config saved, autoAcceptPrompts is now:', loopConfig.autoAcceptPrompts);
    }

    async function updateAutoAcceptDelay(seconds) {
      const delay = parseInt(seconds);
      if (delay >= 1 && delay <= 60) {
        console.log('Updating autoAcceptDelay to:', delay);
        loopConfig.autoAcceptDelay = delay;
        await saveConfig();
        console.log('Config saved, autoAcceptDelay is now:', loopConfig.autoAcceptDelay);
      }
    }

    async function updateAutoAcceptCooldown(minutes) {
      const cooldown = parseInt(minutes);
      if (cooldown >= 0 && cooldown <= 60) {
        console.log('Updating autoAcceptCooldown to:', cooldown);
        loopConfig.autoAcceptCooldown = cooldown;
        await saveConfig();
        console.log('Config saved, autoAcceptCooldown is now:', loopConfig.autoAcceptCooldown);
      }
    }

    async function resetAutoAcceptCooldown() {
      try {
        console.log('Resetting auto-accept cooldown timer for session:', currentSession);
        const response = await dashboardAPI.request('/api/reset-cooldown', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ session: currentSession })
        });

        if (response.success) {
          console.log('Auto-accept cooldown timer reset successfully');
          // Visual feedback
          const btn = event.target;
          const originalText = btn.textContent;
          btn.textContent = '‚úì';
          btn.style.color = '#4CAF50';
          setTimeout(() => {
            btn.textContent = originalText;
            btn.style.color = '';
          }, 1000);
        }
      } catch (error) {
        console.error('Failed to reset cooldown:', error);
      }
    }

    async function updateShowPromptNotifications(show) {
      loopConfig.showPromptNotifications = show;
      await saveConfig();
      // Hide notification immediately if disabled
      if (!show) {
        document.getElementById('prompt-notification').style.display = 'none';
      }
    }

    function togglePromptNotifications() {
      const checkbox = document.getElementById('show-prompt-notifications');
      checkbox.checked = false;
      updateShowPromptNotifications(false);
    }

    // Track if the current prompt instance was dismissed
    let currentPromptDismissed = false;

    function dismissPromptNotification() {
      const promptNotification = document.getElementById('prompt-notification');
      if (promptNotification) {
        currentPromptDismissed = true;
        promptNotification.style.display = 'none';
        console.log('[Notification] Dismissed current prompt instance');
      }
    }

    async function updateAutoAcceptWithoutLoop(enabled) {
      loopConfig.autoAcceptWithoutLoop = enabled;

      // When enabling "Work without loop running", also enable "Auto-accept Claude prompts"
      // since they work together for autonomous operation
      if (enabled) {
        const autoAcceptCheckbox = document.getElementById('auto-accept-prompts');
        if (autoAcceptCheckbox && !autoAcceptCheckbox.checked) {
          autoAcceptCheckbox.checked = true;
          await updateAutoAcceptPrompts(true);
        }
      }

      await saveConfig();
      console.log('Config saved, autoAcceptWithoutLoop is now:', loopConfig.autoAcceptWithoutLoop);
    }
    
    async function updateMessageSendDelay(seconds) {
      const delay = parseInt(seconds);
      if (delay >= 1 && delay <= 30) {
        loopConfig.messageSendDelay = delay;
        await saveConfig();
        console.log('Message send delay updated to:', delay, 'seconds');
      }
    }
    
    async function updateRetryEnterKey(retry) {
      loopConfig.retryEnterKey = retry;
      await saveConfig();
      console.log('Retry Enter key:', retry);
    }

    async function updateEnableAutoCompact(checked) {
      console.log('Updating enableAutoCompact to:', checked);
      loopConfig.enableAutoCompact = checked;

      // Show/hide threshold setting based on checkbox
      const thresholdContainer = document.getElementById('auto-compact-threshold-container');
      if (thresholdContainer) {
        thresholdContainer.style.display = checked ? 'flex' : 'none';
      }

      await saveConfig();
      console.log('Config saved, enableAutoCompact is now:', loopConfig.enableAutoCompact);
    }

    async function updateAutoCompactThreshold(percentage) {
      const threshold = parseInt(percentage);
      if (threshold >= 1 && threshold <= 20) {
        console.log('Updating autoCompactThreshold to:', threshold);
        loopConfig.autoCompactThreshold = threshold;
        await saveConfig();
        console.log('Config saved, autoCompactThreshold is now:', loopConfig.autoCompactThreshold);
      }
    }

    async function updateWorkingDirectory(directory) {
      loopConfig.workingDirectory = directory || '/home/michael/InfiniQuest';
      await saveConfig();
    }

    async function detectSessionCwd() {
      try {
        // Get tmux pane's current directory using the existing endpoint
        const response = await fetch(`/api/tmux-pane-cwd?session=${currentSession}`);
        const data = await response.json();
        
        if (data && data.cwd) {
          // Update button tooltip if we found a CWD
          const btn = document.getElementById('session-cwd-btn');
          if (btn) {
            btn.title = `Use session CWD: ${data.cwd}`;
          }
        }
      } catch (e) {
        // Ignore errors - this is not critical functionality
      }
    }

    async function useSessionCwd() {
      // Try to get current session's working directory from tmux
      try {
        const result = await dashboardAPI.request('/api/tmux-pane-cwd', {
          method: 'GET'
        });
        if (result.cwd) {
          document.getElementById('working-directory').value = result.cwd;
          await updateWorkingDirectory(result.cwd);
        }
      } catch (e) {
        console.warn('Could not detect session working directory');
      }
    }

    async function browseDirectory() {
      // Simple prompt for now, could be enhanced with a file browser later
      const currentPath = document.getElementById('working-directory').value;
      const newPath = prompt('Enter directory path:', currentPath || '/home/michael');
      if (newPath) {
        document.getElementById('working-directory').value = newPath;
        await updateWorkingDirectory(newPath);
      }
    }

    async function saveConfig() {
      try {
        // Add schedule minutes to config if they exist
        if (window.scheduleMinutes) {
          loopConfig.schedule = {
            enabled: true,
            minutes: window.scheduleMinutes,
            precision: parseInt(document.getElementById('schedule-precision')?.value || '15'),
            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
          };
        }
        await dashboardAPI.saveConfig(loopConfig, currentSession);
        return true; // Return success
      } catch (error) {
        console.error('Failed to save config:', error);
        throw error; // Re-throw so calling code knows it failed
      }
    }

    // Make functions globally available for modules and onclick handlers
    window.saveConfig = saveConfig;
    window.updateTmuxLines = updateTmuxLines;
    window.startClaude = startClaude;
    window.stopClaude = stopClaude;
    window.restartClaude = restartClaude;
    window.sendCompact = sendCompact;
    window.sendConfig = sendConfig;
    window.updateWorkingDirectory = updateWorkingDirectory;
    window.useSessionCwd = useSessionCwd;
    window.browseDirectory = browseDirectory;
    window.restartTmux = restartTmux;

    // Send tmux key commands
    async function sendTmuxKey(key) {
      try {
        const session = currentSession || 'claude-loop1';
        await dashboardAPI.sendTmuxKey(session, key);
        // Refresh tmux output after a short delay
        setTimeout(refreshTmux, 200);
      } catch (error) {
        console.error('Failed to send key:', error);
        // Don't show alert for key presses, just log the error
      }
    }

    // Restart tmux session
    async function restartTmux() {
      try {
        const session = currentSession || 'claude-loop1';
        const response = await dashboardAPI.request(`/api/tmux/restart?session=${session}`, {
          method: 'POST'
        });
        
        if (response.success) {
          // Refresh tmux output after a delay to allow session to fully initialize
          setTimeout(refreshTmux, 1500);
          // And refresh again after a longer delay in case Claude is still loading
          setTimeout(refreshTmux, 3000);
          console.log(`Tmux session ${session} restarted successfully`);
        } else {
          alert('Failed to restart tmux session: ' + (response.error || 'Unknown error'));
        }
      } catch (error) {
        console.error('Failed to restart tmux:', error);
        alert('Failed to restart tmux session: ' + error.message);
      }
    }

    // Message history management (per-session)
    let messageHistory = [];
    let historyIndex = -1;
    let currentDraft = '';

    function loadMessageHistory(session) {
      if (!session) {
        messageHistory = [];
        historyIndex = -1;
        currentDraft = '';
        return;
      }
      messageHistory = JSON.parse(localStorage.getItem(`claude-message-history-${session}`) || '[]');
      historyIndex = -1;
      currentDraft = '';
      console.debug(`[Message History] Loaded ${messageHistory.length} messages for session ${session}`);
    }

    function addToMessageHistory(message) {
      if (!currentSession) return; // Safety check

      // Remove duplicate if exists
      messageHistory = messageHistory.filter(m => m !== message);
      // Add to end
      messageHistory.push(message);
      // Keep only last 100 messages
      if (messageHistory.length > 100) {
        messageHistory = messageHistory.slice(-100);
      }
      // Save to session-specific localStorage
      localStorage.setItem(`claude-message-history-${currentSession}`, JSON.stringify(messageHistory));
      // Reset history navigation
      historyIndex = -1;
      currentDraft = '';
    }

    // Format timestamp with day of week and timezone: Mon 2025-11-12 22:12:23 EST
    function formatTimestamp(date) {
      const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
      const dayOfWeek = dayNames[date.getDay()];

      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      const hours = String(date.getHours()).padStart(2, '0');
      const minutes = String(date.getMinutes()).padStart(2, '0');
      const seconds = String(date.getSeconds()).padStart(2, '0');

      // Get timezone abbreviation (EST, PST, etc)
      const timezone = date.toLocaleTimeString('en-US', { timeZoneName: 'short' }).split(' ')[2];

      return `${dayOfWeek} ${year}-${month}-${day} ${hours}:${minutes}:${seconds} ${timezone}`;
    }

    // Format elapsed time in ultra-compact format: +5s, +2m30s, +1h15m, +2d3h
    function formatElapsedTime(milliseconds) {
      const totalSeconds = Math.floor(milliseconds / 1000);
      const totalMinutes = Math.floor(totalSeconds / 60);
      const totalHours = Math.floor(totalMinutes / 60);
      const days = Math.floor(totalHours / 24);

      const hours = totalHours % 24;
      const minutes = totalMinutes % 60;
      const seconds = totalSeconds % 60;

      // Show most significant unit + next unit if non-zero
      if (days > 0) {
        return hours > 0 ? `+${days}d${hours}h` : `+${days}d`;
      } else if (totalHours > 0) {
        return minutes > 0 ? `+${totalHours}h${minutes}m` : `+${totalHours}h`;
      } else if (totalMinutes > 0) {
        return seconds > 0 ? `+${totalMinutes}m${seconds}s` : `+${totalMinutes}m`;
      } else {
        return `+${totalSeconds}s`;
      }
    }

    // Custom message
    async function sendCustomMessage() {
      const messageField = document.getElementById('custom-message');
      const message = messageField.value.trim();
      if (!message) {
        console.warn('Please enter a message');
        return;
      }

      // Clear the message field IMMEDIATELY for instant feedback
      messageField.value = '';
      // Clear the draft immediately
      localStorage.removeItem(`message-draft-${currentSession}`);
      // Reset textarea height to user's preferred height
      const currentPreferredHeight = localStorage.getItem('textarea-preferred-height') || '80';
      messageField.style.height = currentPreferredHeight + 'px';

      // Check if timestamp should be included
      const includeTimestamp = document.getElementById('include-timestamp').checked;
      const now = Date.now();
      let messageToSend = message;

      if (includeTimestamp) {
        // Build timestamp header
        const sessionState = getSessionState(currentSession);
        let timestampHeader = `[${formatTimestamp(new Date(now))}]`;

        // Add elapsed time if we have a previous message time
        if (sessionState.lastManualMessageTime) {
          const elapsed = now - sessionState.lastManualMessageTime;
          timestampHeader += ` ${formatElapsedTime(elapsed)}`;
        }

        // Prepend timestamp to message
        messageToSend = `${timestampHeader}\n${message}`;
      }

      try {
        await dashboardAPI.sendMessage(messageToSend, currentSession);

        // Update session state with new timestamp (regardless of whether we included it in message)
        updateSessionState(currentSession, {
          lastManualMessageTime: now
        });

        // Add to history (original message without timestamp)
        addToMessageHistory(message);
        setTimeout(refreshTmux, 500);
      } catch (error) {
        alert('Failed to send message: ' + error.message);
        // Restore message on error
        messageField.value = message;
      }
    }

    // Auto-save message draft as user types
    function setupMessageAutosave() {
      const messageField = document.getElementById('custom-message');
      let saveTimeout = null;

      messageField.addEventListener('input', () => {
        // Clear previous timeout
        if (saveTimeout) clearTimeout(saveTimeout);

        // Save after 500ms of no typing
        saveTimeout = setTimeout(() => {
          const message = messageField.value;
          if (message && message !== 'cd..' && message !== 'cd ..') {
            localStorage.setItem(`message-draft-${currentSession}`, message);
          }
        }, 500);
      });
    }

    // Setup timestamp toggle preference
    function setupTimestampToggle(session) {
      const checkbox = document.getElementById('include-timestamp');
      if (!checkbox) return;

      // Use current session if not provided
      const sessionId = session || currentSession;
      if (!sessionId) return;

      // Load saved preference for THIS session (default to true if not set)
      const savedPref = localStorage.getItem(`timestamp-${sessionId}`);
      if (savedPref !== null) {
        checkbox.checked = savedPref === 'true';
      } else {
        checkbox.checked = true; // Default to checked
      }

      // Remove old event listeners to prevent duplicates
      const newCheckbox = checkbox.cloneNode(true);
      checkbox.parentNode.replaceChild(newCheckbox, checkbox);

      // Save preference when changed (per-session)
      newCheckbox.addEventListener('change', () => {
        localStorage.setItem(`timestamp-${sessionId}`, newCheckbox.checked);
        console.debug(`[Timestamp] Saved preference for ${sessionId}: ${newCheckbox.checked}`);
      });
    }

    // Status updates
    async function updateStatus() {
      try {
        const status = await dashboardAPI.getStatus(currentSession);

        const indicator = document.getElementById('status-indicator');
        const text = document.getElementById('status-text');
        const countdownDiv = document.getElementById('loop-countdown');
        const countdownTime = document.getElementById('countdown-time');
        const startBtn = document.getElementById('start-resume-btn');

        // Track loop status for refresh optimization
        const wasLoopRunning = isLoopRunning;
        isLoopRunning = status.running && !status.paused;
        
        // If loop status changed, update refresh schedule
        if (wasLoopRunning !== isLoopRunning) {
          console.debug(`[CPU Optimization] Loop status changed: ${isLoopRunning ? 'running' : 'stopped'}`);
          scheduleNextRefresh();
        }

        if (status.running) {
          indicator.style.color = '#4CAF50';

          if (status.paused) {
            text.textContent = 'Paused';
            // Change button to Resume when paused
            if (startBtn) startBtn.innerHTML = '‚ñ∂Ô∏è Resume';
            
            // Update paused state for smooth countdown
            isPaused = true;

            // Check for pause file to get remaining time
            try {
              const pauseInfo = await fetch('/api/pause-status').then(r => r.json());
              if (pauseInfo && pauseInfo.loops && pauseInfo.loops[currentSession]) {
                const remaining = pauseInfo.loops[currentSession].timeRemaining;
                pausedTimeRemaining = remaining; // Store for smooth countdown
                const minutes = Math.floor(remaining / 60000);
                const seconds = Math.floor((remaining % 60000) / 1000);
                countdownTime.textContent = `${minutes}:${seconds.toString().padStart(2, '0')} (paused)`;
                countdownDiv.style.display = 'block';
              } else {
                pausedTimeRemaining = 0;
                countdownDiv.style.display = 'none';
              }
            } catch (e) {
              pausedTimeRemaining = 0;
              countdownDiv.style.display = 'none';
            }
          } else {
            text.textContent = 'Running';
            if (startBtn) startBtn.innerHTML = '‚ñ∂Ô∏è Start';
            
            // Update running state for smooth countdown
            isPaused = false;
            pausedTimeRemaining = 0;

            // Get loop-specific timing info
            try {
              const loopStatus = await fetch('/api/loop/status').then(r => r.json());
              const sessionLoop = loopStatus.loops[currentSession];

              if (sessionLoop && sessionLoop.nextMessageTime) {
                const nextTime = new Date(sessionLoop.nextMessageTime);
                nextMessageTargetTime = nextTime; // Store for smooth countdown
                const now = new Date();
                const diff = nextTime - now;

                if (diff > 0) {
                  const minutes = Math.floor(diff / 60000);
                  const seconds = Math.floor((diff % 60000) / 1000);
                  countdownTime.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                  countdownDiv.style.display = 'block';
                } else {
                  countdownTime.textContent = 'Sending...';
                  countdownDiv.style.display = 'block';
                }
              } else {
                nextMessageTargetTime = null;
                countdownDiv.style.display = 'none';
              }
            } catch (loopError) {
              console.error('Failed to get loop status:', loopError);
              nextMessageTargetTime = null;
              countdownDiv.style.display = 'none';
            }
          }
        } else {
          indicator.style.color = '#f44336';
          text.textContent = 'Stopped';
          // Reset countdown state when stopped
          nextMessageTargetTime = null;
          isPaused = false;
          pausedTimeRemaining = 0;
          countdownDiv.style.display = 'none';
          if (startBtn) startBtn.innerHTML = '‚ñ∂Ô∏è Start';
        }
      } catch (error) {
        console.error('Failed to update status:', error);
      }
    }
    
    // Smooth countdown display - updates every second locally
    function updateCountdownDisplay() {
      const countdownDiv = document.getElementById('loop-countdown');
      const countdownTime = document.getElementById('countdown-time');
      
      if (!countdownDiv || !countdownTime) return;
      
      // Handle paused state
      if (isPaused && pausedTimeRemaining > 0) {
        const minutes = Math.floor(pausedTimeRemaining / 60000);
        const seconds = Math.floor((pausedTimeRemaining % 60000) / 1000);
        countdownTime.textContent = `${minutes}:${seconds.toString().padStart(2, '0')} (paused)`;
        countdownDiv.style.display = 'block';
        return;
      }
      
      // Handle running state with target time
      if (nextMessageTargetTime && !isPaused) {
        const now = new Date();
        const diff = nextMessageTargetTime - now;
        
        if (diff > 0) {
          const minutes = Math.floor(diff / 60000);
          const seconds = Math.floor((diff % 60000) / 1000);
          countdownTime.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
          countdownDiv.style.display = 'block';
        } else {
          countdownTime.textContent = 'Sending...';
          countdownDiv.style.display = 'block';
        }
      } else if (!isPaused) {
        // No target time and not paused - hide countdown
        countdownDiv.style.display = 'none';
      }
    }

    // Context monitoring
    // Simple function to update context display from tmux response
    function updateContextDisplay(contextPercent) {
      if (contextPercent === null || contextPercent === undefined) return;

      // Update cache with new value (merge with existing state)
      if (currentSession) {
        updateSessionState(currentSession, {
          percent: contextPercent,
          timestamp: Date.now()
        });
      }

      // Update inline context bar in tmux panel
      const fillInline = document.getElementById('context-fill-inline');
      const percentText = document.getElementById('context-percent');

      if (fillInline) {
        fillInline.style.width = contextPercent + '%';
        // Change color based on context level
        if (contextPercent < 30) {
          fillInline.style.background = 'linear-gradient(90deg, #ff4444, #ff6666)';
        } else if (contextPercent < 60) {
          fillInline.style.background = 'linear-gradient(90deg, #ff9944, #ffbb66)';
        } else {
          fillInline.style.background = 'linear-gradient(90deg, #44ff44, #66ff66)';
        }
      }

      if (percentText) {
        percentText.textContent = contextPercent + '%';
      }
    }

    async function updateContext() {
      // This function is now mostly deprecated since context comes with tmux data
      // Keep it for backward compatibility but it should rarely be called
      try {
        const context = await dashboardAPI.getContext(currentSession);

        // Get cached context for this session
        const cached = sessionContextCache[currentSession] || {};

        // Use actual value if provided, otherwise use last known value, otherwise default to 100 for first time
        let percent;
        if (context.contextPercent !== null && context.contextPercent !== undefined) {
          percent = context.contextPercent;
          // Update cache with new value (merge with existing state)
          updateSessionState(currentSession, {
            percent: percent,
            timestamp: Date.now()
          });
        } else {
          // No new value - use cached value or default to 100 for first time only
          percent = cached.percent !== undefined ? cached.percent : 100;
        }

        const charsSinceCompact = context.charsSinceCompact || 0;

        // Calculate estimated context usage
        // Rough estimate: 1 token ‚âà 4 characters for English text
        // Claude's context window is ~200k tokens = ~800k characters
        const maxChars = 800000;
        const estimatedUsage = Math.min(100, Math.round((charsSinceCompact / maxChars) * 100));
        const estimatedRemaining = Math.max(0, 100 - estimatedUsage);

        // Update inline context bar in tmux panel
        const fillInline = document.getElementById('context-fill-inline');
        const percentText = document.getElementById('context-percent');
        const estimateText = document.getElementById('context-estimate');
        const separatorText = document.querySelector('.context-separator');
        const usedLabel = document.getElementById('context-used-label');
        const mainLabel = document.getElementById('context-main-label');

        // Check if we have scraped context from tmux
        const hasScrapedContext = context.source === 'tmux';

        // Update main label based on source
        if (mainLabel) {
          mainLabel.textContent = hasScrapedContext ? 'Context Remaining:' : '(Estimated) Context Remaining:';
        }

        if (fillInline) {
          // Use scraped context if available, otherwise use estimated remaining
          const displayPercent = hasScrapedContext ? percent : estimatedRemaining;
          fillInline.style.width = displayPercent + '%';

          // Color coding
          if (displayPercent > 50) {
            fillInline.style.background = '#4CAF50';
          } else if (displayPercent > 20) {
            fillInline.style.background = '#ff9800';
          } else {
            fillInline.style.background = '#f44336';
          }
        }

        if (percentText) {
          // Show scraped context or estimated remaining
          if (hasScrapedContext) {
            percentText.textContent = percent + '%';
            percentText.style.color = percent < 20 ? '#f44336' : (percent < 50 ? '#ff9800' : '#4CAF50');
          } else {
            percentText.textContent = `~${estimatedRemaining}%`;
            percentText.style.color = estimatedRemaining < 20 ? '#f44336' : (estimatedRemaining < 50 ? '#ff9800' : '#4CAF50');
          }
        }

        // Hide or show the "Used" section based on whether we have scraped context
        if (separatorText) separatorText.style.display = hasScrapedContext ? 'none' : 'inline';
        if (usedLabel) usedLabel.style.display = hasScrapedContext ? 'none' : 'inline';
        if (estimateText) {
          estimateText.style.display = hasScrapedContext ? 'none' : 'inline';
          if (!hasScrapedContext) {
            // Only show if we're using estimated context
            estimateText.textContent = `~${estimatedUsage}%`;
            estimateText.style.color = estimatedUsage > 80 ? '#f44336' : (estimatedUsage > 60 ? '#ff9800' : '#4CAF50');
            // Add title for hover info
            estimateText.title = `Estimated context used from conversation: ${charsSinceCompact.toLocaleString()} chars ‚âà ${Math.round(charsSinceCompact / 4).toLocaleString()} tokens`;
          }
        }

        // Update conditional messaging with context (if function exists)
        if (window.dashboardConditional && typeof dashboardConditional.updateContext === 'function') {
          dashboardConditional.updateContext(percent);
        }
      } catch (error) {
        console.error('Failed to update context:', error);
      }
    }

    // Log monitor controls
    async function startLogMonitor() {
      try {
        await dashboardAPI.request('/api/log-monitor/start', { method: 'POST' });
        updateLogMonitorStatus();
      } catch (error) {
        alert('Failed to start log monitor: ' + error.message);
      }
    }

    async function stopLogMonitor() {
      try {
        await dashboardAPI.request('/api/log-monitor/stop', { method: 'POST' });
        updateLogMonitorStatus();
      } catch (error) {
        alert('Failed to stop log monitor: ' + error.message);
      }
    }

    async function listLogMonitors() {
      try {
        const response = await dashboardAPI.request('/api/log-monitor/list');
        const info = document.getElementById('monitor-info');
        if (response.monitors && response.monitors.length > 0) {
          info.innerHTML = `<small>Active: ${response.monitors.join(', ')}</small>`;
        } else {
          info.innerHTML = '<small>No active monitors</small>';
        }
      } catch (error) {
        console.error('Failed to list monitors:', error);
      }
    }

    async function updateLogMonitorStatus() {
      try {
        const response = await dashboardAPI.request('/api/log-monitor/status');
        const indicator = document.getElementById('monitor-indicator');
        const text = document.getElementById('monitor-text');

        if (response.running) {
          indicator.className = 'status-indicator running';
          text.textContent = 'Running';
        } else {
          indicator.className = 'status-indicator stopped';
          text.textContent = 'Stopped';
        }
      } catch (error) {
        console.error('Failed to update monitor status:', error);
      }
    }

    // Delegate to tmux status module
    window.toggleTmuxStatus = function() {
      if (window.dashboardTmuxStatus) {
        dashboardTmuxStatus.toggle();
      }
    }

    // Tmux monitoring
    let textSelectionPauseTimeout = null;
    let tmuxRefreshPaused = false;

    // Setup idle detection
    function setupIdleDetection() {
      console.log('[CPU Optimization] Initializing event-driven idle detection');
      
      // Track user activity - include touch events for mobile
      const activityEvents = ['mousedown', 'mousemove', 'keypress', 'scroll', 
                             'touchstart', 'touchmove', 'touchend'];
      
      // Idle timeout to mark user as idle after 5 minutes
      let idleTimeout = null;
      
      function resetIdleTimer() {
        lastUserActivity = Date.now();
        
        // Clear existing timeout
        if (idleTimeout) {
          clearTimeout(idleTimeout);
        }
        
        // If was idle, mark as active and restart refresh
        if (isUserIdle) {
          isUserIdle = false;
          console.debug('[CPU Optimization] User active again - waking up refresh');
          scheduleNextRefresh(); // Wake up refresh immediately
        }
        
        // Set new timeout for 5 minutes
        idleTimeout = setTimeout(() => {
          isUserIdle = true;
          console.debug('[CPU Optimization] User idle after 5 minutes');
          // Update refresh schedule (may stop if no loop running)
          scheduleNextRefresh();
        }, IDLE_THRESHOLD_MS);
      }
      
      // Attach activity listeners
      activityEvents.forEach(event => {
        document.addEventListener(event, resetIdleTimer, { passive: true });
      });
      
      // Track page visibility
      document.addEventListener('visibilitychange', () => {
        isPageVisible = !document.hidden;
        console.debug(`[CPU Optimization] Page visibility changed: ${isPageVisible ? 'visible' : 'hidden'}`);
        
        if (isPageVisible) {
          // Page became visible, refresh immediately if needed
          if (currentTab === 'tmux' && currentSession) {
            refreshTmux().catch(err => {
              console.debug('[CPU Optimization] Error refreshing on visibility change:', err);
            });
          }
          // Restart scheduling with new visibility state
          scheduleNextRefresh();
        } else {
          // Page hidden, update scheduling (will slow down)
          scheduleNextRefresh();
        }
      });
      
      // Start the idle timer
      resetIdleTimer();
    }
    

    async function refreshTmux() {
      // Skip refresh if user has paused monitoring for this session
      if (currentSession) {
        const sessionState = getSessionState(currentSession);
        if (sessionState.monitoringPaused) {
          console.debug(`[Monitoring] Paused for ${currentSession} by user`);
          return;
        }
      }

      // Skip refresh if text is being selected or was recently selected
      if (tmuxRefreshPaused) {
        return;
      }

      // Skip refresh if no session is selected yet
      if (!currentSession) {
        console.debug('No session selected yet, skipping tmux refresh');
        return;
      }

      // Skip refresh if not on tmux tab
      if (currentTab !== 'tmux') {
        return;
      }

      // Check if user is currently selecting text in tmux content
      const selection = window.getSelection();
      const tmuxContentElement = document.getElementById('tmux-content');
      if (selection && selection.toString().length > 0 && 
          selection.anchorNode && tmuxContentElement && tmuxContentElement.contains(selection.anchorNode)) {
        // Text is selected in tmux content, pause refresh and set timeout to resume
        tmuxRefreshPaused = true;
        clearTimeout(textSelectionPauseTimeout);
        textSelectionPauseTimeout = setTimeout(() => {
          tmuxRefreshPaused = false;
        }, 5000); // Resume after 5 seconds of no selection
        return;
      }

      try {
        // Get selected line count from dropdown
        const linesSelect = document.getElementById('tmux-lines');
        const lineCount = parseInt(linesSelect ? linesSelect.value : 500);

        const response = await dashboardAPI.getTmuxTail(lineCount, currentSession, currentTab);
        const content = document.getElementById('tmux-content');

        // Check if session is not running
        if (response.sessionNotFound) {
          content.innerHTML = `
            <div style="padding: 20px; text-align: center; color: #999;">
              <div style="font-size: 18px; margin-bottom: 10px;">
                Session <strong>${currentSession}</strong> is not running
              </div>
              <div style="margin-top: 15px;">
                <button onclick="restartTmux()" class="btn btn-warning">üîÑ Start Session</button>
              </div>
            </div>
          `;
          return;
        }

        if (response.content) {
          // Convert ANSI to HTML once
          const htmlContent = dashboardUtils.convertAnsiToHtml(response.content);
          
          // Update main tmux view
          // Preserve scroll position
          const wasAtBottom = Math.abs(content.scrollHeight - content.scrollTop - content.clientHeight) < 50;
          const previousScrollTop = content.scrollTop;

          content.innerHTML = htmlContent;

          // Restore scroll position based on auto-scroll setting
          if (document.getElementById('auto-scroll').checked && wasAtBottom) {
            // If auto-scroll is on and we were at the bottom, stay at bottom
            content.scrollTop = content.scrollHeight;
          } else {
            // Otherwise preserve the scroll position
            content.scrollTop = previousScrollTop;
          }
          
          // Update context percentage if it's included in the response
          if (response.contextPercent !== undefined && response.contextPercent !== null) {
            updateContextDisplay(response.contextPercent);
          }

          // Handle compact completion - reset context to 100%
          if (response.hasCompactPhrase === true) {
            console.log('[Context] Compact completion detected, resetting context to 100%');
            updateContextDisplay(100);
          }

          // Store state in cache for consistency with background tabs
          // This ensures notification and emoji always show the same state
          const updates = {};
          if (response.contextPercent !== null && response.contextPercent !== undefined) {
            updates.percent = response.contextPercent;
            updates.timestamp = Date.now();
          }

          if (response.interactivePrompt) {
            updates.interactivePrompt = {
              detected: response.interactivePrompt.detected,
              type: response.interactivePrompt.type,
              content: response.interactivePrompt.content,
              autoAccepted: response.interactivePrompt.autoAccepted,
              timestamp: Date.now()
            };

            // Track recent auto-accept separately for green indicator persistence
            if (response.interactivePrompt.autoAccepted) {
              updates.recentlyAutoAccepted = Date.now();
              console.debug(`[Auto-Accept] Green indicator set for ${currentSession}`);
            }
          } else {
            // Clear prompt if none detected
            updates.interactivePrompt = null;
            // Don't clear recentlyAutoAccepted - let it expire naturally after 30s
          }

          updateSessionState(currentSession, updates);
          updateSessionTabIndicators(currentSession); // Update emoji immediately

          // Handle interactive prompt notifications
          const promptNotification = document.getElementById('prompt-notification');
          const promptIcon = document.getElementById('prompt-icon');
          const promptTitle = document.getElementById('prompt-title');
          const promptContent = document.getElementById('prompt-content');
          const promptStatus = document.getElementById('prompt-status');

          if (response.interactivePrompt && response.interactivePrompt.detected) {
            // Extract and clean the prompt content first
            const lines = response.interactivePrompt.content.split('\n');
            const questionLine = lines.find(l => l.includes('?')) || lines[0];

            // Strip ANSI escape codes from the prompt content
            const cleanedContent = questionLine
              .replace(/\x1b\[[0-9;]*m/g, '')  // Standard ANSI codes
              .replace(/‚êõ\[[0-9;]*m/g, '')     // Literal escape symbol
              .replace(/‚êõ\[\d+m/g, '')         // Simple escape codes
              .trim();

            promptContent.textContent = cleanedContent;

            // Set title and icon based on prompt type
            if (response.interactivePrompt.autoAccepted) {
              promptIcon.textContent = '‚úÖ';
              promptTitle.textContent = 'Auto-accepted Claude\'s prompt';
              promptNotification.className = 'prompt-notification prompt-notification-success';
            } else {
              promptIcon.textContent = '‚ö†Ô∏è';
              promptTitle.textContent = 'Claude is waiting for input';
              promptNotification.className = 'prompt-notification';
            }

            // Show notification only if enabled AND current prompt instance wasn't dismissed
            if (loopConfig.showPromptNotifications !== false && !currentPromptDismissed) {
              promptNotification.style.display = 'block';
            } else if (currentPromptDismissed) {
              console.log('[Notification] Suppressed (current prompt instance was dismissed)');
            }
            
            // Show status
            if (response.interactivePrompt.autoAccepted) {
              promptStatus.textContent = `Pressed Enter at ${new Date(response.interactivePrompt.autoAcceptTime).toLocaleTimeString()}`;
            } else if (response.interactivePrompt.autoAcceptCooldown && response.interactivePrompt.autoAcceptCooldown.active) {
              // Show cooldown status
              const remaining = response.interactivePrompt.autoAcceptCooldown.remainingMinutes;
              promptStatus.textContent = `‚è±Ô∏è Auto-accept cooldown: ${remaining} minute${remaining === 1 ? '' : 's'} remaining`;
              promptStatus.style.color = '#ff9944'; // Orange color for cooldown
            } else if (response.interactivePrompt.hasDefaultYes) {
              promptStatus.textContent = 'Press Enter to accept default (Yes) or type your response';
              promptStatus.style.color = ''; // Reset color
            } else {
              promptStatus.textContent = 'Type your response in the terminal';
              promptStatus.style.color = ''; // Reset color
            }
          } else {
            // Hide notification when no prompt detected
            promptNotification.style.display = 'none';
            // Clear dismissed flag - next prompt can show notification again
            currentPromptDismissed = false;
          }
          
          // Only update the compact status view when on chat tab
          // No need to process tmux data twice when we're already on the tmux tab
          if (currentTab === 'chat' && window.dashboardTmuxStatus) {
            dashboardTmuxStatus.updateFromProcessedContent(htmlContent);
          }
        }
      } catch (error) {
        console.error('Failed to refresh tmux:', error);
      }
    }

    // Update visual indicators for a session tab based on cached state
    function updateSessionTabIndicators(sessionId) {
      const tab = document.querySelector(`.session-tab[data-session="${sessionId}"]`);
      if (!tab) return;

      const state = getSessionState(sessionId);
      const now = Date.now();

      // Remove all indicator classes first
      tab.classList.remove('has-prompt', 'has-auto-accepted', 'low-context', 'very-low-context');
      tab.classList.remove('tier-active', 'tier-idle', 'tier-passive', 'tier-dormant');

      // Add tier class for visual styling
      const tier = calculateMonitoringTier(sessionId);
      tab.classList.add(`tier-${tier}`);

      // Check if recently auto-accepted (within last 30 seconds)
      const recentlyAutoAccepted = state.recentlyAutoAccepted &&
        (now - state.recentlyAutoAccepted) < 30000; // 30 seconds

      if (recentlyAutoAccepted) {
        // Show green indicator for 30s after auto-accept (even if prompt is gone)
        tab.classList.add('has-auto-accepted');
      } else if (state.interactivePrompt && state.interactivePrompt.detected) {
        // Show yellow indicator for active prompt (not yet accepted)
        tab.classList.add('has-prompt');
      }

      // Add context warning indicators
      if (state.percent !== null) {
        if (state.percent < 10) {
          tab.classList.add('very-low-context');
        } else if (state.percent < 30) {
          tab.classList.add('low-context');
        }
      }
    }

    // Lightweight background refresh for auto-accept on inactive tabs
    // Captures state (context, prompts) and stores in cache, skips DOM updates
    async function refreshTmuxBackground(session) {
      // Check if monitoring is paused for this session
      const sessionState = getSessionState(session);
      if (sessionState.monitoringPaused) {
        console.debug(`[Background Refresh] Skipped ${session} - paused by user`);
        return;
      }

      try {
        // Get tmux data - backend handles prompt detection and auto-accept
        const response = await dashboardAPI.getTmuxTail(100, session, 'background');

        // Detect content changes for tiered monitoring
        // Fallback: response might be string directly or object with .content property
        const currentContent = (typeof response === 'string' ? response : response.content) || '';
        const contentHash = currentContent.length + ':' + currentContent.substring(0, 100); // Simple hash
        const previousHash = sessionState.lastContent;
        const contentChanged = previousHash && (contentHash !== previousHash);

        // Store the state in cache for this session
        const updates = {
          lastRefreshed: Date.now(),
          lastContent: contentHash
        };

        // Track content changes
        if (contentChanged) {
          // Content has changed since last check
          updates.lastChanged = Date.now();
          updates.consecutiveNoChanges = 0;
          console.debug(`[Tier] Content changed for ${session}`);
        } else if (previousHash) {
          // Content unchanged (only increment if we had previous content to compare)
          updates.consecutiveNoChanges = (sessionState.consecutiveNoChanges || 0) + 1;
        } else {
          // First time we have content - initialize lastChanged
          updates.lastChanged = Date.now();
          updates.consecutiveNoChanges = 0;
          console.debug(`[Tier] Initialized change tracking for ${session}`);
        }

        // Capture context percentage if available
        if (response.contextPercent !== null && response.contextPercent !== undefined) {
          updates.percent = response.contextPercent;
          updates.timestamp = Date.now();
        }

        // Capture interactive prompt state
        if (response.interactivePrompt) {
          updates.interactivePrompt = {
            detected: response.interactivePrompt.detected,
            type: response.interactivePrompt.type,
            content: response.interactivePrompt.content,
            autoAccepted: response.interactivePrompt.autoAccepted,
            timestamp: Date.now()
          };

          // Track recent auto-accept separately for green indicator persistence
          if (response.interactivePrompt.autoAccepted) {
            updates.recentlyAutoAccepted = Date.now();
            console.debug(`[Auto-Accept] Green indicator set for ${session}`);
          }

          // Promote to active tier when prompt detected
          updates.tier = 'active';
        } else {
          // Clear prompt if none detected
          updates.interactivePrompt = null;
          // Don't clear recentlyAutoAccepted - let it expire naturally after 30s
        }

        // Update cache if we have any new data
        if (Object.keys(updates).length > 0) {
          // First apply updates to cache
          updateSessionState(session, updates);

          // Then recalculate tier based on updated state (unless we just set it due to prompt)
          if (!updates.tier) {
            const newTier = calculateMonitoringTier(session);
            if (newTier !== sessionState.tier) {
              updateSessionState(session, { tier: newTier });
              console.debug(`[Tier] ${session} tier changed: ${sessionState.tier} -> ${newTier}`);
            }
          }

          console.debug(`[Background Refresh] Updated state for ${session}:`, updates);
        }

        // Update visual indicators for this session's tab
        updateSessionTabIndicators(session);

      } catch (error) {
        console.debug(`[Background Refresh] Error checking ${session}:`, error);
      }
    }

    // Monitor text selection changes
    document.addEventListener('selectionchange', () => {
      const selection = window.getSelection();
      if (selection && selection.toString().length > 0) {
        // Check if selection is within the tmux content area
        const tmuxContent = document.getElementById('tmux-content');
        
        // Only pause if selection is within tmux content
        if (selection.anchorNode && tmuxContent && tmuxContent.contains(selection.anchorNode)) {
          // Text is being selected in tmux content, pause refresh
          tmuxRefreshPaused = true;
          clearTimeout(textSelectionPauseTimeout);
        } else {
          // Selection is not in tmux content, don't pause
          tmuxRefreshPaused = false;
        }
      } else if (tmuxRefreshPaused) {
        // Selection cleared, start countdown to resume
        clearTimeout(textSelectionPauseTimeout);
        textSelectionPauseTimeout = setTimeout(() => {
          tmuxRefreshPaused = false;
        }, 5000); // Resume after 5 seconds
      }
    });

    // Also monitor mouseup to detect when selection is complete
    document.addEventListener('mouseup', () => {
      const selection = window.getSelection();
      if (selection && selection.toString().length > 0) {
        // Check if selection is within the tmux content area
        const tmuxContent = document.getElementById('tmux-content');
        
        // Only pause if selection is within tmux content
        if (selection.anchorNode && tmuxContent && tmuxContent.contains(selection.anchorNode)) {
          // Text was selected in tmux content, ensure refresh is paused
          tmuxRefreshPaused = true;
          clearTimeout(textSelectionPauseTimeout);
          textSelectionPauseTimeout = setTimeout(() => {
            tmuxRefreshPaused = false;
          }, 5000); // Resume after 5 seconds
        }
      }
    });

    // Keyboard shortcuts for sending messages and tmux control
    let enterHoldTimeout = null;
    let enterHoldStartTime = null;
    let progressAnimationFrame = null;

    function updateProgressIndicator(progress, showCheckmark = false) {
      const progressSvg = document.getElementById('enter-progress');
      const progressCircle = document.getElementById('progress-circle');
      const checkmark = document.getElementById('progress-checkmark');

      if (showCheckmark) {
        // Show checkmark when message is sent
        progressSvg.style.display = 'block';
        progressCircle.style.strokeDashoffset = 0; // Full circle
        progressCircle.style.stroke = '#4CAF50'; // Green color
        checkmark.style.display = 'block';
        
        // Hide everything after a short delay
        setTimeout(() => {
          progressSvg.style.display = 'none';
          progressCircle.style.strokeDashoffset = 113;
          progressCircle.style.stroke = '#fff';
          checkmark.style.display = 'none';
        }, 500);
      } else if (progress > 0) {
        progressSvg.style.display = 'block';
        checkmark.style.display = 'none';
        progressCircle.style.stroke = '#fff';
        // Calculate stroke-dashoffset (113 is the circumference for r=18)
        const offset = 113 - (113 * progress);
        progressCircle.style.strokeDashoffset = offset;
      } else {
        progressSvg.style.display = 'none';
        progressCircle.style.strokeDashoffset = 113;
        progressCircle.style.stroke = '#fff';
        checkmark.style.display = 'none';
      }
    }

    function animateProgress() {
      if (enterHoldStartTime) {
        const elapsed = Date.now() - enterHoldStartTime;
        const progress = Math.min(elapsed / 1000, 1); // 0 to 1 over 1 second

        updateProgressIndicator(progress);

        if (progress < 1) {
          progressAnimationFrame = requestAnimationFrame(animateProgress);
        }
      }
    }

    document.addEventListener('keydown', async (event) => {
      const customMessageInput = document.getElementById('custom-message');
      const isInMessageInput = document.activeElement === customMessageInput;

      // Handle Enter key hold for 1 second to send message to Claude
      if (event.key === 'Enter' && !event.ctrlKey && !event.shiftKey && !event.altKey && isInMessageInput) {
        if (!enterHoldStartTime) {
          // First Enter press - start tracking
          enterHoldStartTime = Date.now();

          // Start progress animation
          animateProgress();

          // Set timeout for 1 second
          enterHoldTimeout = setTimeout(async () => {
            // Check if we're still holding (will be cleared on keyup if released early)
            if (enterHoldStartTime) {
              // Show checkmark to indicate sending
              updateProgressIndicator(1, true); // Show checkmark
              
              // Send the message (it will clear the field itself)
              await sendCustomMessage();
              
              // Reset tracking
              enterHoldStartTime = null;
              enterHoldTimeout = null;
              if (progressAnimationFrame) {
                cancelAnimationFrame(progressAnimationFrame);
                progressAnimationFrame = null;
              }
            }
          }, 700);
          
          // Allow the first Enter to insert a newline (for tapping Enter)
          // Don't prevent default on first press
        } else {
          // This is a repeat event from holding down Enter
          // Prevent additional newlines from being inserted
          event.preventDefault();
        }
      }

      // Handle Ctrl+Up/Down for message history navigation
      if (isInMessageInput && event.ctrlKey && (event.key === 'ArrowUp' || event.key === 'ArrowDown')) {
        event.preventDefault();
        
        if (event.key === 'ArrowUp') {
          // Save current draft if starting navigation
          if (historyIndex === -1) {
            currentDraft = customMessageInput.value;
          }
          
          // Move up in history
          if (historyIndex < messageHistory.length - 1) {
            historyIndex++;
            customMessageInput.value = messageHistory[messageHistory.length - 1 - historyIndex];
            // Trigger input event to adjust height
            customMessageInput.dispatchEvent(new Event('input'));
          }
        } else if (event.key === 'ArrowDown') {
          // Move down in history
          if (historyIndex > -1) {
            historyIndex--;
            if (historyIndex === -1) {
              // Back to current draft
              customMessageInput.value = currentDraft;
            } else {
              customMessageInput.value = messageHistory[messageHistory.length - 1 - historyIndex];
            }
            // Trigger input event to adjust height
            customMessageInput.dispatchEvent(new Event('input'));
          }
        }
        return;
      }

      // Handle Ctrl+B to send tmux prefix
      if ((event.key === 'b' || event.key === 'B') && event.ctrlKey && !event.altKey && !event.shiftKey) {
        event.preventDefault();
        await sendTmuxKey('C-b');
      }

      // Handle Ctrl+Enter to send Enter to tmux
      if (event.key === 'Enter' && event.ctrlKey) {
        event.preventDefault();
        await sendTmuxKey('Enter');
      }

      // Handle Alt+Enter to send Enter to tmux (additional shortcut)
      if (event.key === 'Enter' && event.altKey) {
        event.preventDefault();
        await sendTmuxKey('Enter');
      }

      // Handle Shift+Tab to send to tmux
      if (event.shiftKey && event.key === 'Tab' && !event.ctrlKey && !event.altKey) {
        event.preventDefault();
        await sendTmuxKey('BTab');
      }

      // Handle Alt+Arrow keys for tmux (changed from Ctrl+Arrow)
      if (event.altKey && !event.ctrlKey && !event.shiftKey) {
        switch (event.key) {
          case 'ArrowLeft':
            event.preventDefault();
            await sendTmuxKey('Left');
            break;
          case 'ArrowUp':
            event.preventDefault();
            await sendTmuxKey('Up');
            break;
          case 'ArrowDown':
            event.preventDefault();
            await sendTmuxKey('Down');
            break;
          case 'ArrowRight':
            event.preventDefault();
            await sendTmuxKey('Right');
            break;
        }
      }

      // Handle Escape key (without Ctrl)
      if (event.key === 'Escape' && !event.ctrlKey && !event.shiftKey && !event.altKey) {
        event.preventDefault();
        await sendTmuxKey('Escape');
      }
    });

    document.addEventListener('keyup', (event) => {
      // Clear Enter hold tracking when Enter is released
      if (event.key === 'Enter') {
        if (enterHoldTimeout) {
          clearTimeout(enterHoldTimeout);
          enterHoldTimeout = null;
        }
        enterHoldStartTime = null;
        updateProgressIndicator(0);
        if (progressAnimationFrame) {
          cancelAnimationFrame(progressAnimationFrame);
          progressAnimationFrame = null;
        }
      }
    });


    // Update tmux lines when dropdown changes
    async function updateTmuxLines() {
      // Save the selection to config
      const linesSelect = document.getElementById('tmux-lines');
      if (linesSelect) {
        loopConfig.tmuxLines = parseInt(linesSelect.value);
        await saveConfig();
      }
      await refreshTmux();
    }

    function clearTmux() {
      document.getElementById('tmux-content').innerHTML = '';
    }

    async function sendToTmux() {
      const input = document.getElementById('tmux-command');
      const command = input.value.trim();
      if (!command) return;

      try {
        await dashboardAPI.sendToTmux(command, currentSession);
        input.value = '';
        setTimeout(refreshTmux, 500);
      } catch (error) {
        alert('Failed to send command: ' + error.message);
      }
    }

    function handleTmuxInput(event) {
      if (event.key === 'Enter') {
        sendToTmux();
      }
    }

    // Claude control functions
    async function startClaude() {
      try {
        await dashboardAPI.request('/api/claude/start', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ session: currentSession })
        });

        // Wait a bit then refresh display
        setTimeout(refreshTmux, 500);
      } catch (error) {
        alert('Failed to start Claude: ' + error.message);
      }
    }

    async function stopClaude() {
      try {
        await dashboardAPI.request('/api/claude/stop', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ session: currentSession })
        });

        // Wait a bit then refresh display
        setTimeout(refreshTmux, 500);
      } catch (error) {
        alert('Failed to stop Claude: ' + error.message);
      }
    }

    async function restartClaude() {
      try {
        // Show status that we're restarting
        const statusDiv = document.getElementById('status');
        if (statusDiv) {
          statusDiv.innerHTML = '<span style="color: #FF9800;">üîÑ Restarting Claude...</span>';
        }
        
        const response = await dashboardAPI.request('/api/claude/restart', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ session: currentSession })
        });

        // Show success
        if (statusDiv) {
          const message = response.resumed 
            ? `‚úì Claude restarted with conversation ${response.conversationId.slice(0, 8)}...`
            : '‚úì Claude restarted';
          statusDiv.innerHTML = `<span style="color: #4CAF50;">${message}</span>`;
        }

        // Refresh display after a moment
        setTimeout(() => {
          refreshTmux();
          updateStatus();
          refreshSessions(); // Update session tabs in case new session was created
        }, 2000);
      } catch (error) {
        alert('Failed to restart Claude: ' + error.message);
      }
    }

    async function sendCompact() {
      try {
        // Send /compact through the message system (handles delay + Enter automatically)
        await dashboardAPI.sendMessage('/compact', currentSession);

        // Reset context to 100% since we're manually compacting
        console.log('[Context] Manual compact triggered, will reset to 100% after completion');

        // Wait for the delay + enter to complete, then refresh and reset context
        // Message sender has 5s delay + enter, so wait ~7s total
        setTimeout(() => {
          refreshTmux();
          updateContext();
          // Reset to 100% after compact completes
          setTimeout(() => {
            updateContextDisplay(100);
          }, 2000);
        }, 7000);
      } catch (error) {
        alert('Failed to send compact: ' + error.message);
      }
    }

    // Toggle monitoring pause for current session
    function toggleMonitoringPause() {
      if (!currentSession) return;

      const state = getSessionState(currentSession);
      const isPaused = state.monitoringPaused || false;

      updateSessionState(currentSession, {
        monitoringPaused: !isPaused,
        pausedAt: !isPaused ? Date.now() : null,
        pausedBy: 'user'
      });

      updatePauseButton();

      console.log(`[Monitoring] ${isPaused ? 'Resumed' : 'Paused'} monitoring for ${currentSession}`);

      if (isPaused) {
        // Resuming - do immediate refresh
        refreshTmux().catch(err => {
          console.debug('[Monitoring] Error on resume refresh:', err);
        });
      }
    }

    // Update pause button text and style based on current state
    function updatePauseButton() {
      const button = document.getElementById('pause-monitoring-btn');
      const textFull = document.getElementById('pause-monitoring-text');
      const textCompact = document.getElementById('pause-monitoring-compact');

      if (!button || !textFull || !textCompact || !currentSession) return;

      const state = getSessionState(currentSession);
      const isPaused = state.monitoringPaused || false;

      if (isPaused) {
        // Show Resume
        textFull.textContent = '‚ñ∂Ô∏è Resume Monitoring';
        textCompact.textContent = '‚ñ∂Ô∏è Resume';
        button.className = 'btn btn-success';
        button.title = 'Resume tmux monitoring for this session';
      } else {
        // Show Pause
        textFull.textContent = '‚è∏Ô∏è Pause Monitoring';
        textCompact.textContent = '‚è∏Ô∏è Pause';
        button.className = 'btn btn-secondary';
        button.title = 'Pause tmux monitoring for this session';
      }
    }

    // Clear tmux scrollback buffer (fixes flickering/redraw issues from long history)
    async function clearScrollback() {
      if (!currentSession) {
        console.error('[Scrollback] No active session');
        return;
      }

      try {
        console.log(`[Scrollback] Clearing buffer for ${currentSession}...`);

        // Call tmux clear-history command directly (not as keys)
        await dashboardAPI.request('/api/clear-history', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ session: currentSession })
        });

        console.log(`[Scrollback] Successfully cleared buffer for ${currentSession}`);

        // Refresh display after a short delay to show the cleared state
        setTimeout(() => {
          refreshTmux();
        }, 500);
      } catch (error) {
        console.error('[Scrollback] Failed to clear:', error);
        alert('Failed to clear scrollback: ' + error.message);
      }
    }

    async function sendConfig() {
      try {
        // Send /config through the message system (handles delay + Enter automatically)
        await dashboardAPI.sendMessage('/config', currentSession);
        // Wait for the delay + enter to complete, then refresh display
        // Message sender has 5s delay + enter, so wait ~7s total
        setTimeout(refreshTmux, 7000);
      } catch (error) {
        alert('Failed to send /config: ' + error.message);
      }
    }

    async function sendForwardSlash() {
      try {
        // Send just a forward slash character (no Enter)
        await dashboardAPI.sendToTmux('/', currentSession);
        // Quick refresh to show the slash appeared
        setTimeout(refreshTmux, 500);
      } catch (error) {
        alert('Failed to send forward slash: ' + error.message);
      }
    }

    // On-screen keyboard functions
    let keyboardModifiers = {
      shift: false,
      ctrl: false,
      alt: false
    };

    function toggleKeyboard() {
      const keyboard = document.getElementById('on-screen-keyboard');
      const toggle = document.getElementById('keyboard-toggle');

      if (keyboard.style.display === 'none') {
        keyboard.style.display = 'block';
        toggle.textContent = '‚å®Ô∏è Hide Keyboard';
      } else {
        keyboard.style.display = 'none';
        toggle.textContent = '‚å®Ô∏è Keyboard';
        // Reset modifiers when hiding
        keyboardModifiers = { shift: false, ctrl: false, alt: false };
        updateModifierKeys();
      }
    }

    function toggleShift() {
      keyboardModifiers.shift = !keyboardModifiers.shift;
      updateModifierKeys();
    }

    function toggleCtrl() {
      keyboardModifiers.ctrl = !keyboardModifiers.ctrl;
      updateModifierKeys();
    }

    function toggleAlt() {
      keyboardModifiers.alt = !keyboardModifiers.alt;
      updateModifierKeys();
    }

    function updateModifierKeys() {
      const shiftKey = document.getElementById('shift-key');
      const ctrlKey = document.getElementById('ctrl-key');
      const altKey = document.getElementById('alt-key');

      if (shiftKey) {
        if (keyboardModifiers.shift) {
          shiftKey.classList.add('active');
        } else {
          shiftKey.classList.remove('active');
        }
      }

      if (ctrlKey) {
        if (keyboardModifiers.ctrl) {
          ctrlKey.classList.add('active');
        } else {
          ctrlKey.classList.remove('active');
        }
      }

      if (altKey) {
        if (keyboardModifiers.alt) {
          altKey.classList.add('active');
        } else {
          altKey.classList.remove('active');
        }
      }
    }

    async function sendChar(char) {
      try {
        let charToSend = char;

        // Apply shift modifier for letters and symbols
        if (keyboardModifiers.shift) {
          const shiftMap = {
            '`': '~', '1': '!', '2': '@', '3': '#', '4': '$', '5': '%',
            '6': '^', '7': '&', '8': '*', '9': '(', '0': ')', '-': '_',
            '=': '+', '[': '{', ']': '}', '\\\\': '|', ';': ':', "'": '"',
            ',': '<', '.': '>', '/': '?'
          };

          if (shiftMap[char]) {
            charToSend = shiftMap[char];
          } else if (char.match(/[a-z]/)) {
            charToSend = char.toUpperCase();
          }

          // Auto-release shift after one keypress
          keyboardModifiers.shift = false;
          updateModifierKeys();
        }

        // Handle ctrl modifier - use sendTmuxKey for proper key handling
        if (keyboardModifiers.ctrl) {
          await dashboardAPI.sendTmuxKey(currentSession, `C-${charToSend}`);
          keyboardModifiers.ctrl = false;
          updateModifierKeys();
        }
        // Handle alt modifier
        else if (keyboardModifiers.alt) {
          await dashboardAPI.sendTmuxKey(currentSession, `M-${charToSend}`);
          keyboardModifiers.alt = false;
          updateModifierKeys();
        }
        // Normal character - use sendTmuxKey to avoid automatic Enter
        else {
          await dashboardAPI.sendTmuxKey(currentSession, charToSend);
        }

        // Quick refresh to show the character appeared
        setTimeout(refreshTmux, 200);
      } catch (error) {
        console.error('Failed to send character:', error);
      }
    }

    // Helper function for single quote (avoids HTML escaping issues)
    async function sendSingleQuote() {
      console.log('[Keyboard] sendSingleQuote called');
      await sendChar("'");
      console.log('[Keyboard] sendSingleQuote completed');
    }

    // Schedule management
    function toggleSchedule() {
      const card = document.getElementById('schedule-card');
      const content = document.getElementById('schedule-content');
      const toggle = card.querySelector('.toggle');

      if (card.classList.contains('collapsed')) {
        card.classList.remove('collapsed');
        content.style.display = 'block';
        toggle.textContent = '‚ñº';
        // Initialize schedule when opened
        if (window.dashboardSchedule) {
          dashboardSchedule.init();
        }
      } else {
        card.classList.add('collapsed');
        content.style.display = 'none';
        toggle.textContent = '‚ñ∂';
      }
    }

    function editSchedule() {
      // Show schedule modal
      document.getElementById('schedule-modal').style.display = 'block';
    }

    function closeScheduleModal() {
      document.getElementById('schedule-modal').style.display = 'none';
    }

    async function toggleScheduleEnabled() {
      // Implementation needed
      alert('Schedule toggle coming soon');
    }

    // Tab switching - removed duplicate definition (already defined earlier)

    window.refreshCurrentTab = function () {
      if (currentTab === 'chat') {
        dashboardChat.refresh();
      } else {
        refreshTmux();
      }
    }

    window.clearCurrentTab = function () {
      if (currentTab === 'chat') {
        dashboardChat.clearChat();
      } else {
        clearTmux();
      }
    }

    // Chat functionality moved to dashboard-chat.js module for cleaner code organization

    // Theme management functions
    window.updateTheme = function () {
      const themeMode = localStorage.getItem('themeMode') || 'auto';
      const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;

      let isDark = false;
      const icon = document.getElementById('dark-mode-icon');
      const text = document.getElementById('dark-mode-text');

      switch (themeMode) {
        case 'auto':
          isDark = prefersDark;
          icon.textContent = isDark ? 'üåô' : '‚òÄÔ∏è';
          text.textContent = 'Auto';
          break;
        case 'light':
          isDark = false;
          icon.textContent = '‚òÄÔ∏è';
          text.textContent = 'Light';
          break;
        case 'dark':
          isDark = true;
          icon.textContent = 'üåô';
          text.textContent = 'Dark';
          break;
      }

      if (isDark) {
        document.documentElement.classList.add('dark-mode');
        document.body.classList.add('dark-mode');
      } else {
        document.documentElement.classList.remove('dark-mode');
        document.body.classList.remove('dark-mode');
      }
    }

    window.toggleDarkMode = function () {
      const currentMode = localStorage.getItem('themeMode') || 'auto';
      let nextMode;

      // Cycle: Auto ‚Üí Light ‚Üí Dark ‚Üí Auto
      switch (currentMode) {
        case 'auto':
          nextMode = 'light';
          break;
        case 'light':
          nextMode = 'dark';
          break;
        case 'dark':
          nextMode = 'auto';
          break;
        default:
          nextMode = 'auto';
      }

      if (nextMode === 'auto') {
        localStorage.removeItem('themeMode');
      } else {
        localStorage.setItem('themeMode', nextMode);
      }

      updateTheme();
    }

    // Sidebar collapse/expand functionality
    window.toggleSidebar = function () {
      const grid = document.getElementById('dashboard-grid');
      const icon = document.getElementById('sidebar-toggle-icon');
      const isCollapsed = grid.classList.contains('sidebar-collapsed');

      if (isCollapsed) {
        // Expand
        grid.classList.remove('sidebar-collapsed');
        document.body.classList.remove('sidebar-collapsed');
        icon.textContent = '‚óÄ';
        localStorage.setItem('sidebarCollapsed', 'false');
      } else {
        // Collapse
        grid.classList.add('sidebar-collapsed');
        document.body.classList.add('sidebar-collapsed');
        icon.textContent = '‚ñ∂';
        localStorage.setItem('sidebarCollapsed', 'true');
      }
    }

    // Load sidebar state on page load
    window.loadSidebarState = function () {
      const isCollapsed = localStorage.getItem('sidebarCollapsed') === 'true';
      if (isCollapsed) {
        const grid = document.getElementById('dashboard-grid');
        const icon = document.getElementById('sidebar-toggle-icon');
        grid.classList.add('sidebar-collapsed');
        document.body.classList.add('sidebar-collapsed');
        icon.textContent = '‚ñ∂';
      }

      // Load mobile collapse state separately
      const isMobileCollapsed = localStorage.getItem('mobileSidebarCollapsed') === 'true';
      if (isMobileCollapsed) {
        document.body.classList.add('mobile-sidebar-collapsed');
        const mobileText = document.getElementById('mobile-toggle-text');
        const mobileIcon = document.getElementById('mobile-toggle-icon');
        if (mobileText) mobileText.textContent = 'Show Controls';
        if (mobileIcon) mobileIcon.textContent = '‚ñº';
      }
    }

    // Mobile sidebar collapse/expand functionality
    window.toggleMobileSidebar = function () {
      const isCollapsed = document.body.classList.contains('mobile-sidebar-collapsed');
      const mobileText = document.getElementById('mobile-toggle-text');
      const mobileIcon = document.getElementById('mobile-toggle-icon');

      if (isCollapsed) {
        // Expand
        document.body.classList.remove('mobile-sidebar-collapsed');
        if (mobileText) mobileText.textContent = 'Hide Controls';
        if (mobileIcon) mobileIcon.textContent = '‚ñ≤';
        localStorage.setItem('mobileSidebarCollapsed', 'false');
      } else {
        // Collapse
        document.body.classList.add('mobile-sidebar-collapsed');
        if (mobileText) mobileText.textContent = 'Show Controls';
        if (mobileIcon) mobileIcon.textContent = '‚ñº';
        localStorage.setItem('mobileSidebarCollapsed', 'true');
      }
    }

    // Start monitoring intervals
    function startMonitoring() {
      // Update status every 5 seconds (reduced from 1 second)
      setInterval(updateStatus, 5000);
      
      // Smooth countdown display - update every second
      setInterval(updateCountdownDisplay, 1000);

      // Context now comes bundled with tmux data, rarely need standalone update
      // Only update context every 60 seconds as a fallback
      setInterval(updateContext, 60000);

      // Chat refresh - only when on chat tab
      // Store interval ID so we can stop it when switching tabs
      let chatRefreshInterval = null;
      
      // Start/stop chat refresh based on tab
      function updateChatRefresh() {
        if (currentTab === 'chat' && !tmuxRefreshPaused) {
          if (!chatRefreshInterval) {
            console.log('[Dashboard] Starting chat refresh interval');
            chatRefreshInterval = setInterval(() => {
              dashboardChat.refresh();
            }, 5000);
          }
        } else {
          if (chatRefreshInterval) {
            console.log('[Dashboard] Stopping chat refresh interval');
            clearInterval(chatRefreshInterval);
            chatRefreshInterval = null;
          }
        }
      }
      
      // Update chat refresh when tab changes
      updateChatRefresh();

      // Background context check for non-active sessions with running loops
      // This is important for loop control to determine which message to send
      setInterval(async () => {
        try {
          // Get all sessions with running loops
          const status = await dashboardAPI.getStatus();
          
          // Check each session that has an active loop but isn't the current session
          for (const [session, info] of Object.entries(status.sessions || {})) {
            if (info.hasLoop && !info.paused && session !== currentSession) {
              // Silently update context for this session (don't update UI)
              const response = await dashboardAPI.getTmuxTail(100, session);
              // The context will be scraped and used by the loop control
              // We don't need to do anything with the response here
            }
          }
        } catch (error) {
          console.debug('Background context check error:', error);
        }
      }, 25000); // Every 25 seconds as you suggested

      // Initial loads
      updateStatus();
      updateContext();

      // Initialize modules with safety checks
      if (window.dashboardChat) {
        dashboardChat.init();
      } else {
        console.error('dashboardChat not loaded - skipping init');
      }
      
      if (window.dashboardTmuxStatus) {
        dashboardTmuxStatus.init();
      } else {
        console.error('dashboardTmuxStatus not loaded - skipping init');
      }
      
      if (window.dashboardConversations) {
        dashboardConversations.init(); // Load conversations in background
      } else {
        console.error('dashboardConversations not loaded - skipping init');
        // Retry after a delay
        setTimeout(() => {
          if (window.dashboardConversations) {
            console.log('Retrying dashboardConversations.init()');
            dashboardConversations.init();
          }
        }, 1000);
      }

      // Restore tab preference from localStorage
      const preferredTab = localStorage.getItem('preferred-tab') || 'tmux';
      
      // Switch to the preferred tab (this will also load its content)
      switchTab(preferredTab);

      updateLogMonitorStatus();
      setupMessageAutosave();
      setupTimestampToggle();

      // Load message history for initial session
      if (currentSession) {
        loadMessageHistory(currentSession);
      }

      // Initialize todo system
      initTodos();
    }
    
    // Todo System Functions
    let todos = [];
    
    // Initialize project-related variables first
    let todoProjectFilter = (function() {
      const savedProject = localStorage.getItem('selected-todo-project');
      const savedTime = localStorage.getItem('selected-todo-project-time');
      
      // If we have a saved project from less than 10 minutes ago, use it
      if (savedProject && savedTime) {
        const minutesSinceSelection = (Date.now() - parseInt(savedTime)) / (1000 * 60);
        if (minutesSinceSelection < 10) {
          return savedProject;
        }
      }
      
      // Otherwise default to current session if available
      return currentSession || 'all';
    })();
    
    let todoProjects = new Set(); // Track all unique projects
    let projectSidebarOpen = false;
    let todoSearchQuery = ''; // Track search query for todos
    
    // Auto-adjust todo container height based on sidebar
    function adjustTodoContainerHeight() {
      const sidebar = document.getElementById('project-sidebar');
      const todosContent = document.getElementById('todos-content');
      
      if (sidebar && todosContent && projectSidebarOpen) {
        // Calculate the actual height needed for sidebar content
        const projectList = document.getElementById('project-list');
        const dropzone = document.getElementById('new-project-dropzone');
        
        if (projectList && dropzone) {
          // Get the total height of sidebar content
          // Add some padding for the header (about 50px) and extra breathing room
          const sidebarContentHeight = projectList.offsetHeight + dropzone.offsetHeight + 100;
          
          // Set minimum height for the todos content container
          todosContent.style.minHeight = Math.max(400, sidebarContentHeight) + 'px';
        }
      }
    }
    
    // Toggle project sidebar
    function toggleProjectSidebar(event) {
      if (event) {
        event.stopPropagation(); // Prevent triggering the todo panel toggle
      }
      
      const sidebar = document.getElementById('project-sidebar');
      const mainContainer = document.getElementById('todo-main-container');
      const toggleIcon = document.getElementById('sidebar-toggle-icon');
      
      projectSidebarOpen = !projectSidebarOpen;
      
      if (projectSidebarOpen) {
        sidebar.style.display = 'block';
        setTimeout(() => {
          sidebar.style.transform = 'translateX(0)';
          mainContainer.style.marginLeft = '200px';
          // Auto-adjust minimum height based on sidebar content
          adjustTodoContainerHeight();
        }, 10);
        toggleIcon.textContent = '‚óÄ';
        populateProjectList();
      } else {
        sidebar.style.transform = 'translateX(-100%)';
        mainContainer.style.marginLeft = '0';
        toggleIcon.textContent = 'üìÅ';
        // Reset min-height when sidebar is closed
        const todosContent = document.getElementById('todos-content');
        if (todosContent) {
          todosContent.style.minHeight = '';
        }
        setTimeout(() => {
          sidebar.style.display = 'none';
        }, 300);
      }
      
      // Save preference
      localStorage.setItem('project-sidebar-open', projectSidebarOpen);
    }
    
    // Initialize selectedStatuses from localStorage or use defaults
    let selectedStatuses = (function() {
      const savedStatuses = localStorage.getItem('selected-todo-statuses');
      if (savedStatuses) {
        try {
          const statuses = JSON.parse(savedStatuses);
          return new Set(statuses);
        } catch (e) {
          console.error('Failed to parse saved filter preferences:', e);
        }
      }
      // Default: show active work (pending, in progress, and awaiting review)
      return new Set(['pending', 'in_progress', 'claude_done']);
    })();
    
    // Initialize date range filters from localStorage or use defaults
    let dateRangeFilters = (function() {
      const savedRanges = localStorage.getItem('todo-date-ranges');
      if (savedRanges) {
        try {
          return JSON.parse(savedRanges);
        } catch (e) {
          console.error('Failed to parse saved date ranges:', e);
        }
      }
      // Defaults: All time for pending/awaiting, 48h for completed
      return {
        pending: 'all',
        claude_done: 'all',
        user_approved: '48h'
      };
    })();
    
    // Populate project list in sidebar
    async function populateProjectList() {
      const projectList = document.getElementById('project-list');
      const sessionOptions = document.getElementById('session-select');
      
      // Get all sessions from the session dropdown (these are all available sessions)
      const allSessions = [];
      if (sessionOptions) {
        for (let option of sessionOptions.options) {
          if (option.value) {
            allSessions.push(option.value);
          }
        }
      }
      
      // Combine sessions with any additional projects from todos
      const allProjects = new Set([...allSessions, ...todoProjects]);
      
      // Count todos per project based on current filters
      const projectCounts = {};
      
      // Helper to check if todo matches current filters
      const matchesFilters = (todo) => {
        // Check status filter
        if (!selectedStatuses.has(todo.status)) return false;
        
        // Check search filter
        if (todoSearchQuery && !todo.text.toLowerCase().includes(todoSearchQuery.toLowerCase())) {
          return false;
        }
        
        // Check date range filters
        const isWithinDateRange = (todo) => {
          const range = dateRangeFilters[todo.status];
          if (!range.enabled) return true;
          
          const todoDate = new Date(todo[range.dateField]);
          const startDate = range.startDate ? new Date(range.startDate) : null;
          const endDate = range.endDate ? new Date(range.endDate) : null;
          
          if (startDate && todoDate < startDate) return false;
          if (endDate && todoDate > endDate) return false;
          
          return true;
        };
        
        if (!isWithinDateRange(todo)) return false;
        
        return true;
      };
      
      // Count only visible todos
      todos.forEach(todo => {
        if (matchesFilters(todo)) {
          const project = todo.project || 'general';
          projectCounts[project] = (projectCounts[project] || 0) + 1;
        }
      });
      
      projectList.innerHTML = '';
      
      // Add current session first (highlighted)
      if (currentSession) {
        const currentOption = sessionOptions ? sessionOptions.querySelector(`option[value="${currentSession}"]`) : null;
        const currentName = currentOption && currentOption.textContent !== currentSession 
          ? currentOption.textContent.replace(/ \(.*\)$/, '')
          : currentSession;
        
        const currentCount = projectCounts[currentSession] || 0;
        const isActive = todoProjectFilter === currentSession;
        projectList.innerHTML += `
          <div class="project-folder" data-project="${currentSession}" 
               style="padding: 8px; margin-bottom: 4px; background: ${isActive ? 'var(--accent)' : 'var(--bg-highlight)'}; color: ${isActive ? 'white' : 'var(--text-primary)'}; border-radius: 4px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; border: 2px solid ${isActive ? 'var(--accent)' : 'transparent'};"
               onclick="setProjectFilter('${currentSession}')"
               ondragover="handleProjectDragOver(event, '${currentSession}')"
               ondragleave="handleProjectDragLeave(event)"
               ondrop="handleProjectDrop(event, '${currentSession}')">
            <span>üìÅ ${escapeHtml(currentName)}</span>
            <span style="background: ${isActive ? 'rgba(255,255,255,0.2)' : 'var(--bg-secondary)'}; padding: 2px 6px; border-radius: 10px; font-size: 11px;">${currentCount}</span>
          </div>
        `;
      }
      
      // Sort sessions/projects numerically for claude-loop sessions
      const sortProjects = (a, b) => {
        // Extract numbers from session names
        const getNum = (str) => {
          const match = str.match(/(\d+)$/);
          return match ? parseInt(match[1]) : Infinity;
        };
        
        const aNum = getNum(a);
        const bNum = getNum(b);
        
        // If both have numbers, sort numerically
        if (aNum !== Infinity && bNum !== Infinity) {
          return aNum - bNum;
        }
        
        // Otherwise sort alphabetically
        return a.localeCompare(b);
      };
      
      // Add other projects/sessions
      Array.from(allProjects).sort(sortProjects).forEach(project => {
        if (project && project !== currentSession) {
          const projectOption = sessionOptions ? sessionOptions.querySelector(`option[value="${project}"]`) : null;
          const projectName = projectOption && projectOption.textContent !== project
            ? projectOption.textContent.replace(/ \(.*\)$/, '')
            : project;
          
          const count = projectCounts[project] || 0;
          const isActive = todoProjectFilter === project;
          projectList.innerHTML += `
            <div class="project-folder" data-project="${project}"
                 style="padding: 8px; margin-bottom: 4px; background: ${isActive ? 'var(--accent)' : 'var(--bg-tertiary)'}; color: ${isActive ? 'white' : 'var(--text-primary)'}; border-radius: 4px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; transition: all 0.2s; border: 2px solid ${isActive ? 'var(--accent)' : 'transparent'};"
                 onclick="setProjectFilter('${project}')"
                 ondragover="handleProjectDragOver(event, '${project}')"
                 ondragleave="handleProjectDragLeave(event)"
                 ondrop="handleProjectDrop(event, '${project}')"
                 onmouseover="this.style.background='${isActive ? 'var(--accent)' : 'var(--bg-hover)'}'"
                 onmouseout="this.style.background='${isActive ? 'var(--accent)' : 'var(--bg-tertiary)'}'">
              <span>üìÅ ${escapeHtml(projectName)}</span>
              <span style="background: ${isActive ? 'rgba(255,255,255,0.2)' : 'var(--bg-secondary)'}; padding: 2px 6px; border-radius: 10px; font-size: 11px;">${count}</span>
            </div>
          `;
        }
      });
      
      // Add "Recently Deleted" folder at the bottom
      const deletedCount = await getDeletedTodosCount();
      if (deletedCount > 0 || todoProjectFilter === 'recently-deleted') {
        const isActive = todoProjectFilter === 'recently-deleted';
        projectList.innerHTML += `
          <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--border-color);">
            <div class="project-folder" data-project="recently-deleted"
                 style="padding: 8px; margin-bottom: 4px; background: ${isActive ? 'var(--accent)' : 'var(--bg-tertiary)'}; color: ${isActive ? 'white' : 'var(--text-secondary)'}; border-radius: 4px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; transition: all 0.2s; border: 2px solid ${isActive ? 'var(--accent)' : 'transparent'}; opacity: 0.8;"
                 onclick="setProjectFilter('recently-deleted')"
                 title="Todos deleted in the last 7 days">
              <span>üóëÔ∏è Recently Deleted</span>
              <span style="background: ${isActive ? 'rgba(255,255,255,0.2)' : 'var(--bg-secondary)'}; padding: 2px 6px; border-radius: 10px; font-size: 11px;">${deletedCount}</span>
            </div>
          </div>
        `;
      }
      
      // Adjust container height after populating the list
      setTimeout(adjustTodoContainerHeight, 10);
    }
    
    // Get count of recently deleted todos
    async function getDeletedTodosCount() {
      try {
        const response = await fetch('/api/todos/deleted');
        const deletedTodos = await response.json();
        return deletedTodos.length;
      } catch (error) {
        console.error('Failed to get deleted todos count:', error);
        return 0;
      }
    }
    
    // Initialize project dropdown with sessions
    function initProjectDropdowns() {
      const projectSelect = document.getElementById('new-todo-project');
      const projectFilter = document.getElementById('todo-project-filter');
      
      if (!projectSelect || !projectFilter) return; // Elements might not exist yet
      
      // Clear and rebuild options
      projectSelect.innerHTML = '';
      
      // Get custom name for current session if available
      const sessionOptions = document.getElementById('session-select');
      const currentOption = sessionOptions ? sessionOptions.querySelector(`option[value="${currentSession}"]`) : null;
      const currentSessionName = currentOption && currentOption.textContent !== currentSession 
        ? currentOption.textContent.replace(/ \(.*\)$/, '') // Remove (session-id) part
        : currentSession;
      
      // Add current session as default
      const currentSessionOption = document.createElement('option');
      currentSessionOption.value = currentSession || 'general';
      currentSessionOption.textContent = currentSessionName || 'General';
      currentSessionOption.selected = true;
      projectSelect.appendChild(currentSessionOption);
      
      // Add other known projects from todos (using custom names where available)
      const projects = Array.from(todoProjects).sort();
      projects.forEach(project => {
        if (project !== (currentSession || 'general')) {
          const option = document.createElement('option');
          option.value = project;
          
          // Try to get custom name for this project if it's a session
          const projectOption = sessionOptions ? sessionOptions.querySelector(`option[value="${project}"]`) : null;
          const projectName = projectOption && projectOption.textContent !== project
            ? projectOption.textContent.replace(/ \(.*\)$/, '')
            : project;
          
          option.textContent = projectName;
          projectSelect.appendChild(option);
        }
      });
      
      // Add option to create new project
      const newProjectOption = document.createElement('option');
      newProjectOption.value = '__new__';
      newProjectOption.textContent = '+ New Project...';
      projectSelect.appendChild(newProjectOption);
      
      // Update filter dropdown
      const filterProjects = ['all', currentSession || 'general', ...projects.filter(p => p !== (currentSession || 'general'))];
      projectFilter.innerHTML = '';
      filterProjects.forEach((project, index) => {
        const option = document.createElement('option');
        option.value = project;
        
        if (project === 'all') {
          option.textContent = 'All Projects';
        } else {
          // Try to get custom name for this project if it's a session
          const filterOption = sessionOptions ? sessionOptions.querySelector(`option[value="${project}"]`) : null;
          const filterName = filterOption && filterOption.textContent !== project
            ? filterOption.textContent.replace(/ \(.*\)$/, '')
            : project;
          option.textContent = filterName;
        }
        
        if (project === todoProjectFilter) {
          option.selected = true;
        }
        projectFilter.appendChild(option);
      });
    }
    
    // Handle project selection change
    document.addEventListener('DOMContentLoaded', () => {
      const projectSelect = document.getElementById('new-todo-project');
      if (projectSelect) {
        projectSelect.addEventListener('change', (e) => {
          if (e.target.value === '__new__') {
            const newProject = prompt('Enter new project name:');
            if (newProject && newProject.trim()) {
              todoProjects.add(newProject.trim());
              initProjectDropdowns();
              projectSelect.value = newProject.trim();
            } else {
              projectSelect.value = currentSession || 'general';
            }
          }
        });
      }
    });

    async function initTodos() {
      await loadTodos();
      
      // Set the project filter dropdown to match the saved/default filter
      const projectFilterDropdown = document.getElementById('todo-project-filter');
      if (projectFilterDropdown) {
        // Make sure the selected project exists in the dropdown
        let hasOption = false;
        for (let option of projectFilterDropdown.options) {
          if (option.value === todoProjectFilter) {
            hasOption = true;
            break;
          }
        }
        
        // If the saved project doesn't exist, fall back to current session or 'all'
        if (!hasOption) {
          todoProjectFilter = currentSession || 'all';
        }
        
        projectFilterDropdown.value = todoProjectFilter;
      }
      
      // Restore sidebar state from localStorage
      const savedSidebarState = localStorage.getItem('project-sidebar-open');
      if (savedSidebarState === 'true') {
        toggleProjectSidebar();
      }
      
      // Update checkboxes to match current selectedStatuses 
      // (which was already restored from localStorage at initialization)
      const pendingCheckbox = document.getElementById('filter-pending');
      const inProgressCheckbox = document.getElementById('filter-in-progress');
      const claudeDoneCheckbox = document.getElementById('filter-claude-done');
      const approvedCheckbox = document.getElementById('filter-approved');
      
      if (pendingCheckbox) {
        pendingCheckbox.checked = selectedStatuses.has('pending');
      }
      if (inProgressCheckbox) {
        inProgressCheckbox.checked = selectedStatuses.has('in_progress');
      }
      if (claudeDoneCheckbox) {
        claudeDoneCheckbox.checked = selectedStatuses.has('claude_done');
      }
      if (approvedCheckbox) {
        approvedCheckbox.checked = selectedStatuses.has('user_approved');
      }
      
      // Update date range dropdowns to match saved preferences
      const pendingRange = document.getElementById('date-range-pending');
      const inProgressRange = document.getElementById('date-range-in_progress');
      const claudeDoneRange = document.getElementById('date-range-claude_done');
      const approvedRange = document.getElementById('date-range-user_approved');
      
      if (pendingRange) {
        pendingRange.value = dateRangeFilters.pending || 'all';
      }
      if (inProgressRange) {
        inProgressRange.value = dateRangeFilters.in_progress || 'all';
      }
      if (claudeDoneRange) {
        claudeDoneRange.value = dateRangeFilters.claude_done || 'all';
      }
      if (approvedRange) {
        approvedRange.value = dateRangeFilters.user_approved || '48h';
      }
      
      // Add keyboard shortcut for quick todo add
      document.addEventListener('keydown', (e) => {
        if (e.altKey && e.key === 't') {
          e.preventDefault();
          const card = document.getElementById('todos-card');
          const content = document.getElementById('todos-content');
          const toggle = document.getElementById('todo-toggle');
          
          if (card.classList.contains('collapsed')) {
            card.classList.remove('collapsed');
            content.style.display = 'block';
            toggle.textContent = '‚ñº';
            loadTodos();
          }
          
          document.getElementById('new-todo-input').focus();
        }
      });
    }

    async function loadTodos() {
      try {
        const response = await fetch('/api/todos');
        const allTodos = await response.json();
        // Filter out deleted todos from normal view
        todos = allTodos.filter(t => t.status !== 'deleted');
        
        // Fix any circular references before rendering
        fixCircularReferences();
        
        // Extract all unique projects
        todoProjects.clear();
        todos.forEach(todo => {
          if (todo.project) {
            todoProjects.add(todo.project);
          }
        });
        
        // Initialize project dropdowns
        initProjectDropdowns();
        
        // Sort by order property if it exists, otherwise maintain original order
        todos.sort((a, b) => (a.order || 0) - (b.order || 0));
        renderTodos();
        updateTodoCount();
      } catch (error) {
        console.error('Failed to load todos:', error);
      }
    }
    
    // Fix any circular references in the todo hierarchy
    function fixCircularReferences() {
      let fixed = false;
      const visited = new Set();
      
      todos.forEach(todo => {
        visited.clear();
        let current = todo;
        
        // Follow the parent chain
        while (current) {
          if (visited.has(current.id)) {
            // Found a circular reference!
            console.warn(`Fixed circular reference: ${todo.text} (${todo.id}) had circular parent chain`);
            todo.parentId = null; // Break the cycle by making it top-level
            fixed = true;
            break;
          }
          visited.add(current.id);
          
          if (current.parentId) {
            current = todos.find(t => t.id === current.parentId);
          } else {
            break;
          }
        }
      });
      
      if (fixed) {
        console.log('Fixed circular references in todo hierarchy');
        // Save the fixed structure
        saveTodoOrder();
      }
    }

    function toggleTodoPanel() {
      const card = document.getElementById('todos-card');
      const content = document.getElementById('todos-content');
      const toggle = document.getElementById('todo-toggle');
      
      if (content.style.display === 'none') {
        card.classList.remove('collapsed');
        content.style.display = 'block';
        toggle.textContent = '‚ñº';
        loadTodos();
        
        // Make sure the project dropdown shows the current session
        setTimeout(() => {
          const projectSelect = document.getElementById('new-todo-project');
          if (projectSelect && currentSession) {
            projectSelect.value = currentSession;
          }
        }, 100);
      } else {
        card.classList.add('collapsed');
        content.style.display = 'none';
        toggle.textContent = '‚ñ∂';
      }
    }

    // Category slider management
    const categories = ['bug', 'feature', 'research', 'other'];
    const categoryIcons = {'bug': 'üêõ', 'feature': '‚ú®', 'research': 'üîç', 'other': 'üìù'};
    const categoryLabels = {'bug': 'Bug', 'feature': 'Feature', 'research': 'Research', 'other': 'Other'};
    let currentCategory = 'other';
    
    function updateCategoryFromSlider(value) {
      const index = parseInt(value);
      currentCategory = categories[index];
      document.getElementById('category-label').textContent = categoryLabels[currentCategory];
      
      // Add snapping effect
      const slider = document.getElementById('todo-category-slider');
      slider.value = index;
    }
    
    function setCategorySlider(index) {
      document.getElementById('todo-category-slider').value = index;
      updateCategoryFromSlider(index);
    }
    
    // Priority slider management
    const priorities = ['low', 'normal', 'high'];
    const priorityLabels = {'low': 'Low', 'normal': 'Normal', 'high': 'Urgent'};
    const priorityIcons = {'low': 'üê¢', 'normal': 'üêé', 'high': 'üöÄ'};
    let currentPriority = 'normal';
    
    function updatePriorityFromSlider(value) {
      const index = parseInt(value);
      currentPriority = priorities[index];
      document.getElementById('priority-label').textContent = priorityLabels[currentPriority];
      
      // Add snapping effect
      const slider = document.getElementById('todo-priority-slider');
      slider.value = index;
    }
    
    function setPrioritySlider(index) {
      document.getElementById('todo-priority-slider').value = index;
      updatePriorityFromSlider(index);
    }
    
    async function addTodo() {
      const input = document.getElementById('new-todo-input');
      const projectSelect = document.getElementById('new-todo-project');
      
      if (!input.value.trim()) return;
      
      const project = projectSelect.value || currentSession || 'general';
      
      try {
        const response = await fetch('/api/todos', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            text: input.value,
            priority: currentPriority,
            category: currentCategory,
            project: project,
            claude_session: currentSession
          })
        });
        
        const newTodo = await response.json();
        
        // Add project to known projects if new
        if (project && !todoProjects.has(project)) {
          todoProjects.add(project);
          initProjectDropdowns();
        }
        
        todos.unshift(newTodo);
        input.value = '';
        renderTodos();
        updateTodoCount();
      } catch (error) {
        console.error('Failed to add todo:', error);
      }
    }

    async function updateTodo(id, updates) {
      try {
        const response = await fetch('/api/todos/update', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ id, ...updates, claude_session: currentSession })
        });
        
        const updatedTodo = await response.json();
        const index = todos.findIndex(t => t.id === id);
        if (index !== -1) {
          todos[index] = updatedTodo;
          renderTodos();
          updateTodoCount();
        }
      } catch (error) {
        console.error('Failed to update todo:', error);
      }
    }

    // Toggle done status (first checkbox)
    function toggleTodoDone(id) {
      const todo = todos.find(t => t.id === id);
      if (!todo) return;
      
      // Cycle through: pending -> in_progress -> claude_done -> pending
      // Or if approved, go back to pending
      let newStatus;
      if (todo.status === 'pending') {
        newStatus = 'in_progress';
      } else if (todo.status === 'in_progress') {
        newStatus = 'claude_done';
      } else {
        newStatus = 'pending';
      }
      updateTodo(id, { status: newStatus });
    }
    
    // Toggle reviewed status (second checkbox)
    function toggleTodoReviewed(id) {
      const todo = todos.find(t => t.id === id);
      if (!todo) return;
      
      // If not approved, mark as approved
      // If approved, go back to claude_done (or pending if it wasn't done)
      let newStatus;
      if (todo.status === 'user_approved') {
        // Un-approve: go back to claude_done if it was done, or pending
        newStatus = 'claude_done';
      } else if (todo.status === 'claude_done') {
        // Approve it
        newStatus = 'user_approved';
      } else {
        // If it's pending, mark as both done and approved
        newStatus = 'user_approved';
      }
      updateTodo(id, { status: newStatus });
    }

    async function deleteTodo(id, skipConfirm = false) {
      if (!skipConfirm && !confirm('Delete this todo?')) return;
      
      try {
        await fetch('/api/todos/delete', {
          method: 'DELETE',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ id, claude_session: currentSession })
        });
        
        todos = todos.filter(t => t.id !== id);
        renderTodos();
        updateTodoCount();
        // Update project list to reflect deleted count
        if (projectSidebarOpen) {
          populateProjectList();
        }
      } catch (error) {
        console.error('Failed to delete todo:', error);
      }
    }
    
    async function restoreTodo(id) {
      try {
        const response = await fetch('/api/todos/restore', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ id, claude_session: currentSession })
        });
        
        const result = await response.json();
        if (result.success) {
          // Reload todos to show the restored item
          await loadTodos();
          // Switch back to the project the todo was restored to
          if (result.todo && result.todo.project) {
            todoProjectFilter = result.todo.project;
            document.getElementById('todo-project-filter').value = todoProjectFilter;
          } else {
            todoProjectFilter = 'all';
            document.getElementById('todo-project-filter').value = 'all';
          }
          renderTodos();
          updateTodoCount();
          // Update project list
          if (projectSidebarOpen) {
            populateProjectList();
          }
          showToast('Todo restored', 'success');
        } else {
          showToast('Failed to restore todo', 'error');
        }
      } catch (error) {
        console.error('Failed to restore todo:', error);
        showToast('Failed to restore todo', 'error');
      }
    }
    
    // History-related functions
    async function checkTodoHistory(todoId) {
      try {
        const response = await fetch(`/api/todos/history/${todoId}`);
        const history = await response.json();
        
        const undoBtn = document.getElementById(`undo-${todoId}`);
        const redoBtn = document.getElementById(`redo-${todoId}`);
        
        if (undoBtn && history.canUndo) {
          undoBtn.style.display = 'inline-block';
          // Update tooltip with description of what will be undone
          if (history.history && history.history.length > 0) {
            const lastChange = history.history[history.currentPosition - 1];
            if (lastChange) {
              undoBtn.title = getUndoDescription(lastChange);
            }
          }
        }
        
        if (redoBtn && history.canRedo) {
          redoBtn.style.display = 'inline-block';
        }
      } catch (error) {
        console.error('Failed to check todo history:', error);
      }
    }
    
    function hideTodoHistoryButtons(todoId) {
      const undoBtn = document.getElementById(`undo-${todoId}`);
      const redoBtn = document.getElementById(`redo-${todoId}`);
      
      // Hide buttons after a small delay to prevent flickering
      setTimeout(() => {
        if (undoBtn && !undoBtn.matches(':hover')) {
          undoBtn.style.display = 'none';
        }
        if (redoBtn && !redoBtn.matches(':hover')) {
          redoBtn.style.display = 'none';
        }
      }, 100);
    }
    
    async function undoTodo(todoId) {
      try {
        const response = await fetch(`/api/todos/undo/${todoId}`, {
          method: 'POST'
        });
        const result = await response.json();
        
        if (result.success) {
          // Reload todos to show the change
          await loadTodos();
          showToast('Change undone', 'success');
        } else {
          showToast(result.message || 'Could not undo', 'error');
        }
      } catch (error) {
        console.error('Failed to undo:', error);
        showToast('Failed to undo change', 'error');
      }
    }
    
    async function redoTodo(todoId) {
      try {
        const response = await fetch(`/api/todos/redo/${todoId}`, {
          method: 'POST'
        });
        const result = await response.json();
        
        if (result.success) {
          // Reload todos to show the change
          await loadTodos();
          showToast('Change redone', 'success');
        } else {
          showToast(result.message || 'Could not redo', 'error');
        }
      } catch (error) {
        console.error('Failed to redo:', error);
        showToast('Failed to redo change', 'error');
      }
    }
    
    function getUndoDescription(change) {
      switch (change.action) {
        case 'UPDATE':
          if (change.field === 'text') {
            return 'Undo text edit';
          } else if (change.field === 'priority') {
            return `Restore priority to ${change.oldValue}`;
          } else if (change.field === 'project') {
            return `Move back to ${change.oldValue || 'unassigned'}`;
          } else if (change.field === 'parentId') {
            return 'Undo parent change';
          }
          return `Undo ${change.field} change`;
        case 'ADD':
          return 'Remove this todo';
        case 'DELETE':
          return 'Restore deleted todo';
        case 'MOVE':
          return `Move back to ${change.oldProject || 'unassigned'}`;
        default:
          return 'Undo last change';
      }
    }
    
    // Simple toast notification function
    function showToast(message, type = 'info') {
      const toast = document.createElement('div');
      toast.className = `toast toast-${type}`;
      toast.textContent = message;
      toast.style.cssText = `
        position: fixed;
        bottom: 20px;
        right: 20px;
        padding: 12px 20px;
        background: ${type === 'success' ? '#4CAF50' : type === 'error' ? '#f44336' : '#2196F3'};
        color: white;
        border-radius: 4px;
        z-index: 10000;
        animation: slideIn 0.3s ease;
      `;
      document.body.appendChild(toast);
      
      setTimeout(() => {
        toast.style.animation = 'slideOut 0.3s ease';
        setTimeout(() => toast.remove(), 300);
      }, 3000);
    }
    
    // Inline editing functions
    let currentlyEditing = null;
    
    function startEditingTodo(todoId) {
      // Don't allow multiple edits at once
      if (currentlyEditing) {
        cancelEditingTodo();
      }
      
      const todo = todos.find(t => t.id === todoId);
      if (!todo) return;
      
      const textSpan = document.getElementById(`todo-text-${todoId}`);
      if (!textSpan) return;
      
      currentlyEditing = todoId;
      const originalText = todo.text;
      
      // Get computed styles from the text span to match exactly
      const textStyles = window.getComputedStyle(textSpan);
      
      // Create input field
      const input = document.createElement('textarea');
      input.value = originalText;
      input.style.cssText = `
        width: 100%;
        padding: 2px 4px;
        margin: -4px -4px;
        border: 2px solid var(--accent-color);
        border-radius: 4px;
        background: var(--bg-primary);
        color: var(--text-primary);
        font-family: ${textStyles.fontFamily};
        font-size: ${textStyles.fontSize};
        line-height: ${textStyles.lineHeight};
        resize: none;
        min-height: ${textStyles.height};
        overflow-y: hidden;
        box-shadow: 0 0 0 2px rgba(79, 195, 247, 0.2);
        outline: none;
      `;
      
      // Auto-resize textarea
      function autoResize() {
        input.style.height = 'auto';
        input.style.height = input.scrollHeight + 'px';
      }
      
      input.addEventListener('input', autoResize);
      
      // Handle save
      const saveEdit = async () => {
        const newText = input.value.trim();
        if (newText && newText !== originalText) {
          await updateTodo(todoId, { text: newText });
          showToast('Todo updated', 'success');
        } else if (!newText) {
          // Restore original if empty
          input.value = originalText;
        }
        currentlyEditing = null;
        renderTodos();
      };
      
      // Handle cancel
      const cancelEdit = () => {
        currentlyEditing = null;
        renderTodos();
      };
      
      // Keyboard shortcuts
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          saveEdit();
        } else if (e.key === 'Escape') {
          cancelEdit();
        }
      });
      
      // Save on blur (click away)
      input.addEventListener('blur', saveEdit);
      
      // Replace span with input
      textSpan.innerHTML = '';
      textSpan.appendChild(input);
      
      // Focus and position cursor at the end
      input.focus();
      input.setSelectionRange(input.value.length, input.value.length);
      autoResize();
    }
    
    function cancelEditingTodo() {
      if (currentlyEditing) {
        currentlyEditing = null;
        renderTodos();
      }
    }
    
    // Multi-select functions with Windows-style selection
    function handleTodoClick(event, todoId) {
      // Don't select when clicking on interactive elements
      if (event.target.closest('input, button, select, span[onclick]')) {
        return;
      }
      
      event.preventDefault();
      
      if (event.ctrlKey || event.metaKey) {
        // Ctrl/Cmd+click: Toggle single selection
        if (selectedTodos.has(todoId)) {
          selectedTodos.delete(todoId);
        } else {
          selectedTodos.add(todoId);
        }
        lastSelectedTodo = todoId;
        
      } else if (event.shiftKey && lastSelectedTodo) {
        // Shift+click: Select range
        const allTodoElements = Array.from(document.querySelectorAll('.todo-item'));
        const todoIds = allTodoElements.map(el => el.dataset.todoId);
        
        const startIndex = todoIds.indexOf(lastSelectedTodo);
        const endIndex = todoIds.indexOf(todoId);
        
        if (startIndex !== -1 && endIndex !== -1) {
          const minIndex = Math.min(startIndex, endIndex);
          const maxIndex = Math.max(startIndex, endIndex);
          
          // Clear previous selection and select range
          selectedTodos.clear();
          for (let i = minIndex; i <= maxIndex; i++) {
            selectedTodos.add(todoIds[i]);
          }
        }
        
      } else {
        // Regular click: Select only this item (unless clicking on already selected)
        if (selectedTodos.size > 1 || !selectedTodos.has(todoId)) {
          selectedTodos.clear();
          selectedTodos.add(todoId);
          lastSelectedTodo = todoId;
        }
      }
      
      updateSelectionUI();
      renderTodos();
    }
    
    function clearSelection() {
      selectedTodos.clear();
      updateSelectionUI();
      renderTodos();
    }
    
    function updateSelectionUI() {
      const bulkBar = document.getElementById('bulk-actions-bar');
      const countSpan = document.getElementById('selected-count');
      
      if (selectedTodos.size > 0) {
        bulkBar.style.display = 'flex';
        countSpan.textContent = selectedTodos.size;
      } else {
        bulkBar.style.display = 'none';
      }
    }
    
    async function executeBulkAction() {
      const action = document.getElementById('bulk-action-select').value;
      if (!action || selectedTodos.size === 0) return;
      
      switch(action) {
        case 'delete':
          if (confirm(`Delete ${selectedTodos.size} selected todos?`)) {
            for (const todoId of selectedTodos) {
              await deleteTodo(todoId, true); // Skip individual confirmations
            }
            clearSelection();
          }
          break;
          
        case 'mark-done':
          for (const todoId of selectedTodos) {
            const todo = todos.find(t => t.id === todoId);
            if (todo && todo.status === 'pending') {
              await updateTodoStatus(todoId, 'claude_done');
            }
          }
          clearSelection();
          break;
          
        case 'mark-approved':
          for (const todoId of selectedTodos) {
            const todo = todos.find(t => t.id === todoId);
            if (todo && todo.status !== 'user_approved') {
              await updateTodoStatus(todoId, 'user_approved');
            }
          }
          clearSelection();
          break;
          
        case 'move-project':
          const newProject = prompt('Enter project name:');
          if (newProject) {
            for (const todoId of selectedTodos) {
              await fetch('/api/todos/update', {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ id: todoId, project: newProject })
              });
            }
            await loadTodos();
            clearSelection();
          }
          break;
      }
      
      // Reset dropdown
      document.getElementById('bulk-action-select').value = '';
    }
    
    // Drag and drop for multi-select
    let draggedTodos = [];
    
    function handleDragStart(event, todoId) {
      // Don't drag when clicking on interactive elements
      if (event.target.closest('input, button, select, span[onclick]')) {
        event.preventDefault();
        return;
      }
      
      // If dragging a selected todo, drag all selected
      if (selectedTodos.has(todoId)) {
        draggedTodos = Array.from(selectedTodos);
      } else {
        // Just drag this single todo
        draggedTodos = [todoId];
      }
      
      event.dataTransfer.effectAllowed = 'move';
      event.dataTransfer.setData('text/plain', JSON.stringify(draggedTodos));
      
      // Visual feedback for all dragged items
      draggedTodos.forEach(id => {
        const element = document.querySelector(`[data-todo-id="${id}"]`);
        if (element) element.style.opacity = '0.5';
      });
    }
    
    function handleDragEnd(event) {
      // Reset visual feedback for all dragged items
      draggedTodos.forEach(id => {
        const element = document.querySelector(`[data-todo-id="${id}"]`);
        if (element) element.style.opacity = '1';
      });
      draggedTodos = [];
    }

    function updateStatusFilters() {
      // Get selected statuses from checkboxes
      selectedStatuses.clear();
      
      if (document.getElementById('filter-pending').checked) {
        selectedStatuses.add('pending');
      }
      if (document.getElementById('filter-in-progress').checked) {
        selectedStatuses.add('in_progress');
      }
      if (document.getElementById('filter-claude-done').checked) {
        selectedStatuses.add('claude_done');
      }
      if (document.getElementById('filter-approved').checked) {
        selectedStatuses.add('user_approved');
      }
      
      // Get date ranges from dropdowns
      dateRangeFilters.pending = document.getElementById('date-range-pending').value;
      dateRangeFilters.in_progress = document.getElementById('date-range-in_progress').value;
      dateRangeFilters.claude_done = document.getElementById('date-range-claude_done').value;
      dateRangeFilters.user_approved = document.getElementById('date-range-user_approved').value;
      
      // Handle custom date selection
      ['pending', 'in_progress', 'claude_done', 'user_approved'].forEach(status => {
        if (dateRangeFilters[status] === 'custom') {
          // For now, fallback to 'all' until we implement date picker
          // TODO: Show date picker modal
          dateRangeFilters[status] = 'all';
          document.getElementById(`date-range-${status === 'claude_done' ? 'claude_done' : status}`).value = 'all';
        }
      });
      
      // Save preferences to localStorage
      localStorage.setItem('selected-todo-statuses', JSON.stringify([...selectedStatuses]));
      localStorage.setItem('todo-date-ranges', JSON.stringify(dateRangeFilters));
      
      renderTodos();
      // Update project counts to reflect new filters
      if (projectSidebarOpen) {
        populateProjectList();
      }
    }
    
    function filterByProject() {
      todoProjectFilter = document.getElementById('todo-project-filter').value;
      // Save the selected project to localStorage
      localStorage.setItem('selected-todo-project', todoProjectFilter);
      localStorage.setItem('selected-todo-project-time', Date.now()); // Track when it was selected
      renderTodos();
      // Update project counts to reflect new filters
      if (projectSidebarOpen) {
        populateProjectList();
      }
    }
    
    function setProjectFilter(project) {
      // Toggle: if clicking the active project, go back to "all"
      if (todoProjectFilter === project) {
        todoProjectFilter = 'all';
      } else {
        todoProjectFilter = project;
      }
      
      // Save the selected project to localStorage
      localStorage.setItem('selected-todo-project', todoProjectFilter);
      localStorage.setItem('selected-todo-project-time', Date.now());
      
      // Update the dropdown to match
      document.getElementById('todo-project-filter').value = todoProjectFilter;
      
      // Re-render to show filtered todos and update sidebar highlighting
      renderTodos();
      populateProjectList();
    }
    
    function manageProjects() {
      // Show a simple modal to manage projects
      const projects = Array.from(todoProjects).sort();
      const projectList = projects.length > 0 
        ? projects.map(p => `‚Ä¢ ${p}`).join('\n')
        : 'No projects yet';
      
      alert(`Current Projects:\n${projectList}\n\nProjects are automatically created when you add todos.\nUse the dropdown when adding todos to select or create projects.`);
    }
    
    function fixAndResetHierarchy() {
      if (confirm('This will:\n1. Fix any circular references\n2. Optionally flatten all sub-tasks to top level\n\nDo you want to also flatten all sub-tasks?')) {
        // User wants to flatten everything
        todos.forEach(todo => {
          todo.parentId = null;
        });
        console.log('Flattened all todos to top level');
      } else {
        // Just fix circular references
        fixCircularReferences();
      }
      
      // Save and re-render
      saveTodoOrder();
      renderTodos();
      alert('Hierarchy has been fixed!');
    }

    async function renderTodos() {
      const list = document.getElementById('todo-list');
      
      // Special handling for "recently-deleted" view
      if (todoProjectFilter === 'recently-deleted') {
        try {
          const response = await fetch('/api/todos/deleted');
          const deletedTodos = await response.json();
          
          if (deletedTodos.length === 0) {
            list.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-secondary);">No recently deleted todos</div>';
            return;
          }
          
          // Render deleted todos with restore option
          let html = '<div style="padding: 10px; font-size: 11px; color: var(--text-secondary); border-bottom: 1px solid var(--border-color);">Todos deleted in the last 7 days (auto-cleared after 7 days)</div>';
          
          deletedTodos.forEach(todo => {
            const deletedDate = new Date(todo.deleted_at).toLocaleDateString();
            const deletedTime = new Date(todo.deleted_at).toLocaleTimeString();
            html += `
              <div class="todo-item" style="padding: 8px 10px; border-bottom: 1px solid var(--border-color); opacity: 0.7;">
                <div style="display: flex; justify-content: space-between; align-items: start;">
                  <div style="flex: 1;">
                    <div style="text-decoration: line-through; color: var(--text-secondary);">${escapeHtml(todo.text)}</div>
                    <div style="font-size: 10px; color: var(--text-secondary); margin-top: 4px;">
                      Deleted ${deletedDate} at ${deletedTime}
                      ${todo.project ? `from ${todo.project}` : ''}
                    </div>
                  </div>
                  <button onclick="restoreTodo('${todo.id}')" class="btn btn-xs btn-success" style="padding: 2px 6px; font-size: 10px;" title="Restore">‚Ü© Restore</button>
                </div>
              </div>
            `;
          });
          
          list.innerHTML = html;
          return;
        } catch (error) {
          console.error('Failed to load deleted todos:', error);
          list.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-secondary);">Failed to load deleted todos</div>';
          return;
        }
      }
      
      // Helper function to check if todo is within date range
      const isWithinDateRange = (todo) => {
        const range = dateRangeFilters[todo.status];
        if (!range || range === 'all') return true;
        
        // Determine which date to check based on status
        let dateToCheck;
        if (todo.status === 'user_approved' && todo.user_approved_at) {
          dateToCheck = new Date(todo.user_approved_at);
        } else if (todo.status === 'claude_done' && todo.claude_completed_at) {
          dateToCheck = new Date(todo.claude_completed_at);
        } else if (todo.created_at) {
          dateToCheck = new Date(todo.created_at);
        } else {
          return true; // No date available, include it
        }
        
        const now = new Date();
        let cutoffDate;
        
        switch(range) {
          case '24h':
            cutoffDate = new Date(now - 24 * 60 * 60 * 1000);
            break;
          case '48h':
            cutoffDate = new Date(now - 48 * 60 * 60 * 1000);
            break;
          case '7d':
            cutoffDate = new Date(now - 7 * 24 * 60 * 60 * 1000);
            break;
          case '30d':
            cutoffDate = new Date(now - 30 * 24 * 60 * 60 * 1000);
            break;
          default:
            return true;
        }
        
        return dateToCheck >= cutoffDate;
      };
      
      // Apply status, project, and date filters in a single pass
      let filteredTodos = todos.filter(t => {
        // Check if status is selected
        if (!selectedStatuses.has(t.status)) {
          return false;
        }
        
        // Check project filter
        if (todoProjectFilter !== 'all' && t.project !== todoProjectFilter) {
          return false;
        }
        
        // Check date range filter
        if (!isWithinDateRange(t)) {
          return false;
        }
        
        return true;
      });
      
      
      if (filteredTodos.length === 0) {
        list.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-secondary);">No todos</div>';
        return;
      }
      
      // Add column headers
      let html = `
        <div style="display: flex; align-items: center; gap: 8px; padding: 4px 10px; border-bottom: 2px solid var(--border-color); background: var(--bg-tertiary); font-size: 12px; color: var(--text-secondary); margin-bottom: 2px;">
          <div style="display: flex; gap: 4px; align-items: center; margin-left: 0;">
            <div style="width: 36px; text-align: center; font-size: 16px;" title="Mark as done">‚úì</div>
            <div style="width: 36px; text-align: center; font-size: 16px;" title="Mark as reviewed">‚úì‚úì</div>
          </div>
          <div style="flex: 1; padding-left: 28px;">Task</div>
          <div style="width: 140px; text-align: center;">Progress</div>
        </div>
      `;
      
      // Build hierarchy - render parent tasks and their children
      const renderTodoWithChildren = (todo, depth = 0, renderedIds = new Set()) => {
        // Prevent infinite loops from circular references
        if (renderedIds.has(todo.id)) return '';
        renderedIds.add(todo.id);
        
        const childTodos = filteredTodos.filter(t => t.parentId === todo.id && !renderedIds.has(t.id));
        const hasChildren = childTodos.length > 0;
        
        let html = renderTodoItem(todo, depth, hasChildren);
        
        // Render children recursively
        if (hasChildren) {
          childTodos.forEach(child => {
            html += renderTodoWithChildren(child, depth + 1, renderedIds);
          });
        }
        
        return html;
      };
      
      // Start with top-level todos (no parent or parent not in filtered list)
      const allTodoIds = new Set(todos.map(t => t.id)); // Check against ALL todos, not just filtered
      const filteredIds = new Set(filteredTodos.map(t => t.id));
      const topLevelTodos = filteredTodos.filter(t => {
        // A todo is top-level if:
        // 1. It has no parentId, OR
        // 2. Its parent doesn't exist at all, OR  
        // 3. Its parent exists but isn't in the filtered list
        if (!t.parentId) return true;
        if (!allTodoIds.has(t.parentId)) return true; // Parent was deleted
        if (!filteredIds.has(t.parentId)) return true; // Parent is filtered out
        return false;
      });
      
      const renderedIds = new Set();
      topLevelTodos.forEach(todo => {
        html += renderTodoWithChildren(todo, 0, renderedIds);
      });
      
      // Render any orphaned todos that weren't rendered yet (safety net)
      filteredTodos.forEach(todo => {
        if (!renderedIds.has(todo.id)) {
          html += renderTodoItem(todo, 0, false);
          renderedIds.add(todo.id);
        }
      });
      
      list.innerHTML = html;
      
      // Set up drag and drop handlers after rendering
      setupTodoDragAndDrop();
      
      // Update project sidebar if open
      if (projectSidebarOpen) {
        populateProjectList();
      }
    }
    
    function renderTodoItem(todo, depth = 0, hasChildren = false) {
        const statusIcon = todo.status === 'pending' ? 'üî¥' : 
                         todo.status === 'in_progress' ? '‚è≥' :
                         todo.status === 'claude_done' ? 'üü°' : 'üü¢';
        const priorityIcon = priorityIcons[todo.priority] || 'üêé';
        const priorityClass = todo.priority === 'high' ? 'high-priority' : 
                             todo.priority === 'low' ? 'low-priority' : '';
        const categoryIcon = todo.category === 'bug' ? 'üêõ' : 
                           todo.category === 'feature' ? '‚ú®' : 
                           todo.category === 'research' ? 'üîç' : 'üìù';
        
        // Format dates compactly
        const formatDate = (dateStr) => {
          if (!dateStr) return '';
          const date = new Date(dateStr);
          return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        };
        
        // Create timeline visualization
        const createTimeline = () => {
          const created = new Date(todo.created_at);
          const now = new Date();
          const done = todo.claude_completed_at ? new Date(todo.claude_completed_at) : null;
          const approved = todo.user_approved_at ? new Date(todo.user_approved_at) : null;
          
          // Calculate total time span (always use full span for proportions)
          const endTime = approved || done || now;
          const totalMs = endTime - created;
          
          // Calculate positions as percentages
          const donePos = done ? ((done - created) / totalMs) * 100 : 0;
          const approvedPos = approved ? ((approved - created) / totalMs) * 100 : 0;
          
          // Format time durations
          const formatDuration = (ms) => {
            const minutes = Math.floor(ms / 60000);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);
            if (days > 0) return `${days}d ${hours % 24}h`;
            if (hours > 0) return `${hours}h ${minutes % 60}m`;
            return `${minutes}m`;
          };
          
          const phase1Duration = done ? formatDuration(done - created) : formatDuration(now - created);
          const phase2Duration = done && approved ? formatDuration(approved - done) : done ? formatDuration(now - done) : '';
          const totalDuration = formatDuration(totalMs);
          
          // Create detailed tooltip
          const tooltipText = `üìÖ Created: ${formatDate(todo.created_at)}${
            done ? `\nüü° Claude Done: ${formatDate(todo.claude_completed_at)} (${phase1Duration})` : `\n‚è≥ In Progress: ${phase1Duration}`
          }${
            approved ? `\n‚úÖ Approved: ${formatDate(todo.user_approved_at)} (${phase2Duration})` : 
            done ? `\n‚è≥ Awaiting Review: ${phase2Duration}` : ''
          }\n‚è±Ô∏è Total Time: ${totalDuration}`;
          
          return `
            <div style="width: 120px; height: 20px; position: relative; background: #2a2a2a; border-radius: 10px; margin-top: 4px; overflow: hidden; cursor: help;"
                 title="${tooltipText}">
              
              <!-- Progress bars for each phase -->
              ${done ? `
                <!-- Phase 1: Created to Done (green when complete) -->
                <div style="position: absolute; top: 0; left: 0; width: ${donePos}%; height: 100%; background: linear-gradient(90deg, #4a5568 0%, #2d3748 100%); opacity: 0.8;"></div>
              ` : `
                <!-- Phase 1: In progress (animated) -->
                <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(90deg, #4a5568 0%, #2d3748 50%, #4a5568 100%); opacity: 0.6; background-size: 200% 100%; animation: shimmer 3s infinite;"></div>
              `}
              
              ${approved ? `
                <!-- Phase 2: Done to Approved (blue/green) -->
                <div style="position: absolute; top: 0; left: ${donePos}%; width: ${approvedPos - donePos}%; height: 100%; background: linear-gradient(90deg, #ff9800 0%, #4caf50 100%); opacity: 0.8;"></div>
              ` : done ? `
                <!-- Phase 2: Awaiting review (orange pulse) -->
                <div style="position: absolute; top: 0; left: ${donePos}%; width: ${100 - donePos}%; height: 100%; background: #ff9800; opacity: 0.5; animation: pulse-opacity 2s infinite;"></div>
              ` : ''}
              
              <!-- Timeline markers -->
              <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none;">
                <!-- Created node -->
                <div style="position: absolute; left: 8px; top: 6px; width: 8px; height: 8px; background: #6b7280; border: 2px solid #1f2937; border-radius: 50%; z-index: 3;"></div>
                
                ${done ? `
                  <!-- Done node -->
                  <div style="position: absolute; left: ${Math.min(85, Math.max(25, donePos))}%; top: 6px; width: 8px; height: 8px; background: #ff9800; border: 2px solid #1f2937; border-radius: 50%; transform: translateX(-4px); z-index: 2;"></div>
                ` : ''}
                
                ${approved ? `
                  <!-- Approved node -->
                  <div style="position: absolute; left: ${Math.min(92, Math.max(50, approvedPos))}%; top: 6px; width: 8px; height: 8px; background: #4caf50; border: 2px solid #1f2937; border-radius: 50%; transform: translateX(-4px); z-index: 1;"></div>
                ` : ''}
              </div>
            </div>
          `;
        };
        
        // Add indentation and visual hierarchy for sub-tasks
        const indentStyle = depth > 0 ? `margin-left: ${depth * 25}px;` : '';
        const subTaskIndicator = depth > 0 ? '‚îî‚îÄ ' : (hasChildren ? '‚ñº ' : '');
        const isSelected = selectedTodos.has(todo.id);
        const selectedStyle = isSelected ? 'background: rgba(59, 130, 246, 0.1); border-left: 3px solid #3b82f6;' : '';
        
        return `
          <div class="todo-item ${priorityClass} ${isSelected ? 'selected' : ''}" data-todo-id="${todo.id}" data-depth="${depth}" 
            draggable="true"
            onmouseenter="checkTodoHistory('${todo.id}')"
            onmouseleave="hideTodoHistoryButtons('${todo.id}')"
            onclick="handleTodoClick(event, '${todo.id}')"
            ondragstart="handleDragStart(event, '${todo.id}')"
            ondragend="handleDragEnd(event)"
            style="padding: 8px 10px; border-bottom: 1px solid var(--border-color); display: flex; align-items: start; gap: 8px; cursor: move; ${indentStyle} ${selectedStyle}">
            <!-- Two columns of checkboxes on the left -->
            <div style="display: flex; gap: 4px; align-items: center;">
              <!-- Done checkbox -->
              <span 
                onclick="event.stopPropagation(); toggleTodoDone('${todo.id}')" 
                style="font-size: 32px; line-height: 1; cursor: pointer; user-select: none; display: inline-block; width: 36px; text-align: center; transition: transform 0.1s; color: #888;" 
                onmousedown="this.style.transform='scale(0.9)'" 
                onmouseup="this.style.transform='scale(1)'" 
                onmouseleave="this.style.transform='scale(1)'"
                title="${todo.status !== 'pending' ? 'Mark as not done' : 'Mark as done'}">
                ${todo.status !== 'pending' ? '‚òë' : '‚òê'}
              </span>
              
              <!-- Reviewed/Approved checkbox (disabled until done) -->
              <span 
                onclick="${todo.status !== 'pending' ? `event.stopPropagation(); toggleTodoReviewed('${todo.id}')` : 'event.stopPropagation();'}" 
                style="font-size: 32px; line-height: 1; cursor: ${todo.status === 'pending' ? 'not-allowed' : 'pointer'}; user-select: none; display: inline-block; width: 36px; text-align: center; ${todo.status === 'pending' ? 'opacity: 0.25; color: #555;' : 'transition: transform 0.1s; color: #888;'}" 
                ${todo.status !== 'pending' ? `onmousedown="this.style.transform='scale(0.9)'" onmouseup="this.style.transform='scale(1)'" onmouseleave="this.style.transform='scale(1)'"` : ''}
                title="${todo.status === 'pending' ? 'Complete task first' : todo.status === 'user_approved' ? 'Mark as not reviewed' : 'Mark as reviewed'}">
                ${todo.status === 'user_approved' ? '‚òë' : '‚òê'}
              </span>
            </div>
            
            <!-- Main content -->
            <div style="flex: 1; display: flex; flex-direction: column; gap: 4px;">
              <div style="display: flex; align-items: center; gap: 6px;">
                <span style="color: var(--text-secondary); font-size: 12px;">${subTaskIndicator}</span>
                <span>${statusIcon}</span>
                <span title="${priorityLabels[todo.priority] || 'Normal'} priority">${priorityIcon}</span>
                <span>${categoryIcon}</span>
                ${todo.project && todo.project !== currentSession ? `
                  <span style="background: var(--bg-tertiary); color: var(--text-secondary); padding: 2px 6px; border-radius: 4px; font-size: 10px;">
                    ${escapeHtml(todo.project)}
                  </span>
                ` : ''}
                <span 
                  id="todo-text-${todo.id}"
                  ondblclick="startEditingTodo('${todo.id}')"
                  style="flex: 1; cursor: text;"
                  title="Double-click to edit">${escapeHtml(todo.text)}</span>
              </div>
              ${todo.notes && todo.notes.length > 0 ? `
                <div style="padding-left: 32px; font-size: 11px; color: var(--text-secondary);">
                  ${todo.notes.map(n => `<div>üìù ${escapeHtml(n.text)}</div>`).join('')}
                </div>
              ` : ''}
            </div>
            
            <!-- Timeline and delete on the right -->
            <div style="display: flex; gap: 4px; align-items: start;">
              <div style="display: flex; flex-direction: column; align-items: end;">
                ${createTimeline()}
                <div style="font-size: 10px; color: var(--text-secondary); text-align: right; margin-top: 2px;">
                  ${todo.status === 'pending' ? 'Pending' : 
                    todo.status === 'in_progress' ? 'In Progress' :
                    todo.status === 'claude_done' ? 'Awaiting Review' : 
                    'Completed'}
                </div>
              </div>
              <button 
                id="undo-${todo.id}" 
                onclick="undoTodo('${todo.id}')" 
                class="btn btn-xs" 
                style="padding: 2px 4px; font-size: 10px; display: none; opacity: 0.6;" 
                title="Undo last change">‚Ü∂</button>
              <button 
                id="redo-${todo.id}" 
                onclick="redoTodo('${todo.id}')" 
                class="btn btn-xs" 
                style="padding: 2px 4px; font-size: 10px; display: none; opacity: 0.6;" 
                title="Redo">‚Ü∑</button>
              <button onclick="deleteTodo('${todo.id}')" class="btn btn-xs btn-danger" style="padding: 2px 4px; font-size: 10px;" title="Delete">√ó</button>
            </div>
          </div>
        `;
    }
    
    // Drag and drop functionality for reordering todos and creating sub-tasks
    let draggedTodo = null;
    let dragStartX = 0;
    
    function setupTodoDragAndDrop() {
      const todoItems = document.querySelectorAll('.todo-item');
      
      todoItems.forEach(item => {
        item.addEventListener('dragstart', handleDragStart);
        item.addEventListener('dragover', handleDragOver);
        item.addEventListener('drop', handleDrop);
        item.addEventListener('dragend', handleDragEnd);
        item.addEventListener('dragenter', handleDragEnter);
        item.addEventListener('dragleave', handleDragLeave);
      });
    }
    
    function handleDragStart(e) {
      draggedTodo = this;
      dragStartX = e.clientX; // Track starting X position
      this.style.opacity = '0.4';
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/html', this.innerHTML);
      
      // Auto-show project sidebar when dragging starts
      if (!projectSidebarOpen) {
        toggleProjectSidebar();
      }
    }
    
    function handleDragOver(e) {
      if (e.preventDefault) {
        e.preventDefault();
      }
      e.dataTransfer.dropEffect = 'move';
      
      // Visual feedback for making sub-task (dragged to the right)
      if (this !== draggedTodo) {
        const xDiff = e.clientX - dragStartX;
        if (xDiff > 50) { // Dragged more than 50px to the right
          this.style.borderLeft = '4px solid var(--accent)';
          this.style.borderTop = '';
          this.style.paddingLeft = '20px';
        } else {
          this.style.borderLeft = '';
          this.style.borderTop = '2px solid var(--accent)';
          this.style.paddingLeft = '';
        }
      }
      
      return false;
    }
    
    function handleDragEnter(e) {
      // Visual feedback handled in dragOver for better control
    }
    
    function handleDragLeave(e) {
      this.style.borderTop = '';
      this.style.borderLeft = '';
      // Only clear padding if it's the drag-specific 20px padding
      if (this.style.paddingLeft === '20px') {
        this.style.paddingLeft = '';
      }
    }
    
    // Project folder drag and drop handlers
    function handleProjectDragOver(e, project) {
      if (e.preventDefault) {
        e.preventDefault();
      }
      e.dataTransfer.dropEffect = 'move';
      
      // Highlight the project folder
      const folder = e.currentTarget;
      folder.style.background = 'var(--accent)';
      folder.style.transform = 'scale(1.05)';
      
      return false;
    }
    
    function handleProjectDragLeave(e) {
      const folder = e.currentTarget;
      const isCurrentSession = folder.dataset.project === currentSession;
      
      if (isCurrentSession) {
        folder.style.background = 'var(--accent)';
      } else {
        folder.style.background = 'var(--bg-tertiary)';
      }
      folder.style.transform = 'scale(1)';
    }
    
    async function handleProjectDrop(e, project) {
      if (e.stopPropagation) {
        e.stopPropagation();
      }
      
      if (draggedTodo) {
        const todoId = draggedTodo.dataset.todoId;
        const todo = todos.find(t => t.id === todoId);
        
        if (todo && todo.project !== project) {
          // Update the todo's project
          await updateTodo(todoId, { project: project });
          
          // Add project to known projects if new
          if (!todoProjects.has(project)) {
            todoProjects.add(project);
            initProjectDropdowns();
          }
          
          // Update the project list to reflect new counts
          populateProjectList();
        }
      }
      
      // Reset the folder style
      const folder = e.currentTarget;
      const isCurrentSession = folder.dataset.project === currentSession;
      
      if (isCurrentSession) {
        folder.style.background = 'var(--accent)';
      } else {
        folder.style.background = 'var(--bg-tertiary)';
      }
      folder.style.transform = 'scale(1)';
      
      return false;
    }
    
    // Handle drop on new project zone
    function handleNewProjectDrop(e) {
      if (e.preventDefault) {
        e.preventDefault();
      }
      if (e.stopPropagation) {
        e.stopPropagation();
      }
      
      if (draggedTodo) {
        const newProject = prompt('Enter name for new project:');
        if (newProject && newProject.trim()) {
          const todoId = draggedTodo.dataset.todoId;
          updateTodo(todoId, { project: newProject.trim() });
          
          // Add to known projects
          todoProjects.add(newProject.trim());
          initProjectDropdowns();
          populateProjectList();
        }
      }
      
      // Reset dropzone style
      const dropzone = document.getElementById('new-project-dropzone');
      dropzone.style.background = '';
      dropzone.style.opacity = '0.6';
      
      return false;
    }
    
    function handleDrop(e) {
      if (e.stopPropagation) {
        e.stopPropagation();
      }
      
      if (draggedTodo !== this) {
        const draggedId = draggedTodo.getAttribute('data-todo-id');
        const targetId = this.getAttribute('data-todo-id');
        const xDiff = e.clientX - dragStartX;
        
        // Find todos in array
        const draggedTodoItem = todos.find(t => t.id === draggedId);
        const targetTodoItem = todos.find(t => t.id === targetId);
        
        if (draggedTodoItem && targetTodoItem) {
          // Check if target is a child of the dragged item (prevent circular reference)
          const isTargetChildOfDragged = (todoId, potentialParentId) => {
            let current = todos.find(t => t.id === todoId);
            while (current && current.parentId) {
              if (current.parentId === potentialParentId) return true;
              current = todos.find(t => t.id === current.parentId);
            }
            return false;
          };
          
          if (xDiff > 50 && !isTargetChildOfDragged(targetId, draggedId)) {
            // Make it a sub-task of the target (only if not creating circular reference)
            draggedTodoItem.parentId = targetId;
            console.log(`Made ${draggedTodoItem.text} a sub-task of ${targetTodoItem.text}`);
          } else if (xDiff > 50 && isTargetChildOfDragged(targetId, draggedId)) {
            // If trying to make parent a child of its own child, just swap them
            console.log(`Swapping ${draggedTodoItem.text} with its child ${targetTodoItem.text}`);
            
            // Remove parent relationship from the child
            targetTodoItem.parentId = draggedTodoItem.parentId;
            // Make the former parent a sibling instead
            draggedTodoItem.parentId = draggedTodoItem.parentId;
            
            // Swap positions in array
            const draggedIndex = todos.findIndex(t => t.id === draggedId);
            const targetIndex = todos.findIndex(t => t.id === targetId);
            [todos[draggedIndex], todos[targetIndex]] = [todos[targetIndex], todos[draggedIndex]];
          } else {
            // Regular reordering
            const draggedIndex = todos.findIndex(t => t.id === draggedId);
            const targetIndex = todos.findIndex(t => t.id === targetId);
            
            // Clear parent relationship if moving to top level
            if (xDiff < -30) { // Dragged to the left - remove from parent
              draggedTodoItem.parentId = null;
            }
            
            // Remove and reinsert for ordering
            const [removed] = todos.splice(draggedIndex, 1);
            todos.splice(targetIndex, 0, removed);
          }
          
          // Save the changes
          saveTodoOrder();
          // Re-render
          renderTodos();
        }
      }
      
      return false;
    }
    
    function handleDragEnd(e) {
      this.style.opacity = '';
      
      // Only clean up drag-related visual indicators (borders)
      // Don't clear paddingLeft as it might be used for hierarchy indentation
      document.querySelectorAll('.todo-item').forEach(item => {
        // Only clear border styles that were added during drag
        if (item.style.borderTop) {
          item.style.borderTop = '';
        }
        if (item.style.borderLeft) {
          item.style.borderLeft = '';
          // Only clear padding if it was added for drag visual feedback
          // (the 20px padding added during drag-to-make-subtask)
          if (item.style.paddingLeft === '20px') {
            item.style.paddingLeft = '';
          }
        }
      });
    }
    
    async function saveTodoOrder() {
      try {
        // Update the order property for each todo
        todos.forEach((todo, index) => {
          todo.order = index;
        });
        
        // Save both order and parent relationships
        await fetch('/api/todos/reorder', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            todos: todos.map(t => ({ 
              id: t.id, 
              order: t.order,
              parentId: t.parentId || null
            }))
          })
        });
      } catch (error) {
        console.error('Failed to save todo order:', error);
      }
    }

    function updateTodoCount() {
      const pending = todos.filter(t => t.status === 'pending').length;
      const claudeDone = todos.filter(t => t.status === 'claude_done').length;
      const badge = document.getElementById('todo-count');
      
      if (claudeDone > 0) {
        badge.textContent = `${pending}+${claudeDone}`;
        badge.style.background = '#ff9800';
      } else if (pending > 0) {
        badge.textContent = pending;
        badge.style.background = 'var(--danger)';
      } else {
        badge.textContent = '0';
        badge.style.background = 'var(--success)';
      }
    }

    function refreshTodos() {
      loadTodos();
    }

    function exportTodos() {
      const markdown = todos.map(todo => {
        const status = todo.status === 'pending' ? '[ ]' : 
                      todo.status === 'claude_done' ? '[~]' : '[x]';
        return `${status} ${todo.text} (${todo.priority}, ${todo.category})`;
      }).join('\n');
      
      const blob = new Blob([markdown], { type: 'text/markdown' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `todos-${new Date().toISOString().split('T')[0]}.md`;
      a.click();
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
  </script>
</body>

</html>